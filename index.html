<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Virtual Tour Manager</title>
  
  <!-- React and ReactDOM from CDN -->
  <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
  <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
  
  <!-- Babel Standalone for JSX transformation -->
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  
  <!-- Three.js for 3D rendering -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  
  <!-- Tailwind CSS for styling -->
  <script src="https://cdn.tailwindcss.com"></script>
  
  <style>
    body {
      margin: 0;
      padding: 0;
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen', 'Ubuntu', 'Cantarell', sans-serif;
      overflow: hidden;
    }
    #root {
      width: 100%;
      height: 100vh;
    }
  </style>
</head>
<body>
  <div id="root"></div>
  
  <!-- Loading indicator -->
  <div id="loading" style="position: fixed; inset: 0; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); display: flex; align-items: center; justify-center; z-index: 9999;">
    <div style="text-align: center; color: white;">
      <div style="width: 64px; height: 64px; border: 4px solid rgba(255,255,255,0.3); border-top-color: white; border-radius: 50%; animation: spin 1s linear infinite; margin: 0 auto 20px;"></div>
      <div style="font-size: 20px; font-weight: 600;">Loading Virtual Tour Manager...</div>
      <div style="font-size: 14px; margin-top: 8px; opacity: 0.9;">Initializing 360° viewer</div>
    </div>
  </div>
  
  <style>
    @keyframes spin {
      to { transform: rotate(360deg); }
    }
  </style>
  
  <script>
    // Hide loading screen once app loads
    window.addEventListener('load', () => {
      setTimeout(() => {
        const loading = document.getElementById('loading');
        if (loading) {
          loading.style.opacity = '0';
          loading.style.transition = 'opacity 0.5s';
          setTimeout(() => loading.remove(), 500);
        }
      }, 1000);
    });
  </script>
  
  <!-- Application Code -->
  <script type="text/babel" data-type="module">
import React, { useState, useEffect, useRef } from 'react';
import { Camera, Plus, Edit2, Trash2, Eye, EyeOff, LogOut, Save, X, Link, Info, Navigation, ChevronUp, ChevronDown, Home, Map, Play, ExternalLink, Video, Image, FileText, Phone, Mail, MapPin, Calendar, Clock, Download, Upload, Share2, Settings } from 'lucide-react';
import * as THREE from 'three';

const VirtualTourApp = () => {
  // Mapbox configuration
  const MAPBOX_TOKEN = 'pk.eyJ1Ijoic2t5dmlldzJ1IiwiYSI6ImNtazBjb2xqYjA5a3ozY3B2bWk1MjlsbjkifQ.yl4oCLFrFuMjGS-HqhHY7w';
  
  // Skip login for testing - change 'dashboard' back to 'login' to restore login requirement
  const [currentView, setCurrentView] = useState('dashboard');
  // Default user for testing - set back to null when login is restored
  const [currentUser, setCurrentUser] = useState({ username: 'admin', teamId: 'default' });
  const [tours, setTours] = useState([]);
  const [selectedTour, setSelectedTour] = useState(null);
  const [selectedScene, setSelectedScene] = useState(null);
  const [editMode, setEditMode] = useState(false);
  const [viewerTour, setViewerTour] = useState(null);
  const [viewerScene, setViewerScene] = useState(null);
  const [storageWarning, setStorageWarning] = useState('');

  useEffect(() => {
    try {
      const savedTours = JSON.parse(localStorage.getItem('vt_tours') || '[]');
      setTours(savedTours);
    } catch (e) {
      console.warn('Could not load tours from storage:', e);
    }
  }, []);

  useEffect(() => {
    if (tours.length > 0) {
      try {
        localStorage.setItem('vt_tours', JSON.stringify(tours));
        setStorageWarning('');
      } catch (e) {
        if (e.name === 'QuotaExceededError' || e.code === 22) {
          setStorageWarning('Storage limit reached! Use image URLs instead of file uploads for permanent storage.');
        }
      }
    }
  }, [tours]);

  const LoginView = () => {
    const [username, setUsername] = useState('');
    const [password, setPassword] = useState('');
    const [error, setError] = useState('');

    const handleLogin = () => {
      const users = JSON.parse(localStorage.getItem('vt_users') || '[{"username":"admin","password":"admin123","role":"admin"}]');
      const user = users.find(u => u.username === username && u.password === password);
      
      if (user) {
        setCurrentUser(user);
        setCurrentView('dashboard');
        setError('');
      } else {
        setError('Invalid credentials');
      }
    };

    return (
      <div className="min-h-screen bg-gradient-to-br from-blue-500 to-purple-600 flex items-center justify-center p-4">
        <div className="bg-white rounded-lg shadow-2xl p-8 w-full max-w-md">
          <div className="flex items-center justify-center mb-6">
            <Camera className="w-12 h-12 text-blue-600" />
          </div>
          <h1 className="text-3xl font-bold text-center mb-2">Virtual Tour Manager</h1>
          <p className="text-gray-600 text-center mb-6">Team Login Portal</p>
          
          <div className="space-y-4">
            <div>
              <label className="block text-sm font-medium mb-1">Username</label>
              <input
                type="text"
                value={username}
                onChange={(e) => setUsername(e.target.value)}
                className="w-full px-4 py-2 border rounded-lg focus:ring-2 focus:ring-blue-500"
                onKeyPress={(e) => e.key === 'Enter' && handleLogin()}
              />
            </div>
            <div>
              <label className="block text-sm font-medium mb-1">Password</label>
              <input
                type="password"
                value={password}
                onChange={(e) => setPassword(e.target.value)}
                className="w-full px-4 py-2 border rounded-lg focus:ring-2 focus:ring-blue-500"
                onKeyPress={(e) => e.key === 'Enter' && handleLogin()}
              />
            </div>
            {error && <p className="text-red-500 text-sm">{error}</p>}
            <button
              onClick={handleLogin}
              className="w-full bg-blue-600 text-white py-2 rounded-lg hover:bg-blue-700 transition"
            >
              Login
            </button>
          </div>
          
          <div className="mt-6 pt-6 border-t">
            <button
              onClick={() => setCurrentView('public-viewer')}
              className="w-full bg-gray-100 text-gray-700 py-2 rounded-lg hover:bg-gray-200 transition flex items-center justify-center"
            >
              <Eye className="w-4 h-4 mr-2" />
              View Public Tours
            </button>
          </div>
          <div className="mt-4 p-3 bg-blue-50 rounded-lg text-sm text-blue-800">
            <strong>Demo Credentials:</strong><br />
            Username: admin<br />
            Password: admin123
          </div>
        </div>
      </div>
    );
  };

  const Dashboard = () => {
    const [showCreateModal, setShowCreateModal] = useState(false);
    const [newTourName, setNewTourName] = useState('');
    const [deleteConfirm, setDeleteConfirm] = useState(null);
    const [editingTour, setEditingTour] = useState(null);
    const [editTourName, setEditTourName] = useState('');

    const createTour = () => {
      if (!newTourName.trim()) return;
      
      const newTour = {
        id: Date.now().toString(),
        name: newTourName,
        scenes: [],
        published: false,
        showLabels: true, // Labels visible by default
        createdBy: currentUser.username,
        createdAt: new Date().toISOString()
      };
      
      setTours([...tours, newTour]);
      setNewTourName('');
      setShowCreateModal(false);
    };

    const deleteTour = (tourId) => {
      setTours(tours.filter(t => t.id !== tourId));
      setDeleteConfirm(null);
    };

    const togglePublish = (tourId, e) => {
      e.stopPropagation();
      setTours(tours.map(t => 
        t.id === tourId ? { ...t, published: !t.published } : t
      ));
    };

    const startEditTourName = (tour, e) => {
      e.stopPropagation();
      setEditingTour(tour.id);
      setEditTourName(tour.name);
    };

    const saveTourName = () => {
      if (!editTourName.trim()) return;
      setTours(tours.map(t => 
        t.id === editingTour ? { ...t, name: editTourName } : t
      ));
      setEditingTour(null);
      setEditTourName('');
    };

    return (
      <div className="min-h-screen bg-gray-50">
        <nav className="bg-white shadow-sm">
          <div className="max-w-7xl mx-auto px-4 py-4 flex justify-between items-center">
            <div className="flex items-center">
              <Camera className="w-8 h-8 text-blue-600 mr-3" />
              <h1 className="text-2xl font-bold">Virtual Tour Manager</h1>
            </div>
            <div className="flex items-center gap-4">
              <span className="text-sm text-gray-600">Welcome, {currentUser.username}</span>
              {/* Logout button - uncomment when login is restored
              <button
                onClick={() => {
                  setCurrentUser(null);
                  setCurrentView('login');
                }}
                className="flex items-center text-gray-600 hover:text-gray-900"
              >
                <LogOut className="w-4 h-4 mr-1" />
                Logout
              </button>
              */}
            </div>
          </div>
        </nav>

        <div className="max-w-7xl mx-auto px-4 py-8">
          {storageWarning && (
            <div className="mb-6 bg-yellow-50 border-l-4 border-yellow-400 p-4 rounded">
              <div className="flex">
                <div className="ml-3">
                  <p className="text-sm text-yellow-700">{storageWarning}</p>
                </div>
                <button
                  onClick={() => setStorageWarning('')}
                  className="ml-auto text-yellow-700 hover:text-yellow-900"
                >
                  <X className="w-5 h-5" />
                </button>
              </div>
            </div>
          )}

          <div className="flex justify-between items-center mb-6">
            <h2 className="text-2xl font-bold">My Tours</h2>
            <button
              onClick={() => setShowCreateModal(true)}
              className="bg-blue-600 text-white px-4 py-2 rounded-lg hover:bg-blue-700 flex items-center"
            >
              <Plus className="w-4 h-4 mr-2" />
              Create New Tour
            </button>
          </div>

          <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6">
            {tours.map(tour => (
              <div 
                key={tour.id} 
                className="bg-white rounded-lg shadow-md overflow-hidden hover:shadow-lg transition cursor-pointer"
                onClick={() => {
                  setSelectedTour(tour);
                  setCurrentView('editor');
                }}
              >
                {/* Thumbnail */}
                <div className="h-48 bg-gray-900 relative group">
                  {tour.scenes.length > 0 && tour.scenes[0].imageUrl ? (
                    <img 
                      src={tour.scenes[0].imageUrl} 
                      alt={tour.name}
                      className="w-full h-full object-cover group-hover:opacity-90 transition"
                    />
                  ) : (
                    <div className="flex items-center justify-center h-full text-gray-500">
                      <Camera className="w-16 h-16 opacity-50" />
                    </div>
                  )}
                  {/* Hover overlay with hint */}
                  <div className="absolute inset-0 bg-black opacity-0 group-hover:opacity-10 transition"></div>
                  <div className="absolute inset-0 flex items-center justify-center opacity-0 group-hover:opacity-100 transition">
                    <span className="bg-blue-600 text-white px-4 py-2 rounded-lg font-medium shadow-lg flex items-center">
                      <Edit2 className="w-4 h-4 mr-2" />
                      Click to Edit
                    </span>
                  </div>
                  {/* Badges overlay */}
                  <div className="absolute top-2 left-2">
                    <span className="bg-black bg-opacity-75 text-white px-2 py-1 rounded text-xs font-medium">
                      {tour.scenes.length} {tour.scenes.length === 1 ? 'Scene' : 'Scenes'}
                    </span>
                  </div>
                  <div className="absolute top-2 right-2">
                    <span className={`px-3 py-1 rounded-full text-xs font-medium shadow-lg ${tour.published ? 'bg-green-500 text-white' : 'bg-gray-800 bg-opacity-75 text-white'}`}>
                      {tour.published ? 'Published' : 'Draft'}
                    </span>
                  </div>
                </div>

                {/* Tour Info */}
                <div className="p-5">
                  <div className="flex justify-between items-start mb-2">
                    {editingTour === tour.id ? (
                      <input
                        type="text"
                        value={editTourName}
                        onChange={(e) => setEditTourName(e.target.value)}
                        onBlur={saveTourName}
                        onKeyPress={(e) => {
                          e.stopPropagation();
                          if (e.key === 'Enter') saveTourName();
                        }}
                        onClick={(e) => e.stopPropagation()}
                        className="text-xl font-semibold flex-1 px-2 py-1 border border-gray-300 rounded mr-2"
                        autoFocus
                      />
                    ) : (
                      <>
                        <h3 className="text-xl font-semibold flex-1">{tour.name}</h3>
                        <button
                          onClick={(e) => startEditTourName(tour, e)}
                          className="text-gray-400 hover:text-gray-600 p-1"
                          title="Edit tour name"
                        >
                          <Edit2 className="w-4 h-4" />
                        </button>
                      </>
                    )}
                  </div>
                  <div className="flex gap-2 mt-4">
                  <button
                    onClick={(e) => {
                      e.stopPropagation();
                      togglePublish(tour.id, e);
                    }}
                    className="flex-1 bg-purple-50 text-purple-600 px-3 py-2 rounded hover:bg-purple-100 flex items-center justify-center"
                  >
                    <Eye className="w-4 h-4 mr-1" />
                    {tour.published ? 'Unpublish' : 'Publish'}
                  </button>
                  <button
                    onClick={(e) => {
                      e.stopPropagation();
                      setDeleteConfirm({ type: 'tour', id: tour.id, name: tour.name });
                    }}
                    className="bg-red-50 text-red-600 px-3 py-2 rounded hover:bg-red-100"
                  >
                    <Trash2 className="w-4 h-4" />
                  </button>
                </div>
                </div>
              </div>
            ))}
          </div>

          {tours.length === 0 && (
            <div className="text-center py-12">
              <Camera className="w-16 h-16 text-gray-300 mx-auto mb-4" />
              <p className="text-gray-500">No tours yet. Create your first virtual tour!</p>
            </div>
          )}
        </div>

        {showCreateModal && (
          <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center p-4 z-50">
            <div className="bg-white rounded-lg p-6 w-full max-w-md">
              <h3 className="text-xl font-bold mb-4">Create New Tour</h3>
              <input
                type="text"
                value={newTourName}
                onChange={(e) => setNewTourName(e.target.value)}
                placeholder="Tour name"
                className="w-full px-4 py-2 border rounded-lg mb-4"
                autoFocus
                onKeyPress={(e) => e.key === 'Enter' && createTour()}
              />
              <div className="flex gap-2">
                <button
                  onClick={createTour}
                  className="flex-1 bg-blue-600 text-white py-2 rounded-lg hover:bg-blue-700"
                >
                  Create
                </button>
                <button
                  onClick={() => {
                    setShowCreateModal(false);
                    setNewTourName('');
                  }}
                  className="flex-1 bg-gray-200 text-gray-700 py-2 rounded-lg hover:bg-gray-300"
                >
                  Cancel
                </button>
              </div>
            </div>
          </div>
        )}

        {deleteConfirm && (
          <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center p-4 z-50">
            <div className="bg-white rounded-lg p-6 w-full max-w-md">
              <h3 className="text-xl font-bold mb-4">Delete Tour</h3>
              <p className="mb-6">Are you sure you want to delete <strong>"{deleteConfirm.name}"</strong>? This action cannot be undone.</p>
              <div className="flex gap-2">
                <button
                  onClick={() => deleteTour(deleteConfirm.id)}
                  className="flex-1 bg-red-600 text-white py-2 rounded-lg hover:bg-red-700"
                >
                  Delete
                </button>
                <button
                  onClick={() => setDeleteConfirm(null)}
                  className="flex-1 bg-gray-200 text-gray-700 py-2 rounded-lg hover:bg-gray-300"
                >
                  Cancel
                </button>
              </div>
            </div>
          </div>
        )}
      </div>
    );
  };

  // Helper function for creating navigation icon textures
  const createNavigationIconTexture = (inverted = false) => {
    const canvas = document.createElement('canvas');
    canvas.width = 512;
    canvas.height = 512;
    const ctx = canvas.getContext('2d');
    
    const centerX = 256;
    const centerY = 256;
    
    // Colors
    const bgColor = inverted ? '#000000' : '#FFFFFF';
    const chevronColor = inverted ? '#FFFFFF' : '#444444';
    
    // Clear with transparent background
    ctx.clearRect(0, 0, 512, 512);
    
    // Draw much smaller in center with lots of padding
    // Outer ring (subtle)
    ctx.beginPath();
    ctx.arc(centerX, centerY, 85, 0, Math.PI * 2);
    ctx.strokeStyle = inverted ? 'rgba(255,255,255,0.2)' : 'rgba(68,68,68,0.15)';
    ctx.lineWidth = 3;
    ctx.stroke();
    
    // Main thick ring with gradient for depth
    const gradient = ctx.createRadialGradient(centerX, centerY, 55, centerX, centerY, 72);
    if (inverted) {
      gradient.addColorStop(0, 'rgba(255,255,255,0)');
      gradient.addColorStop(0.7, 'rgba(255,255,255,0.8)');
      gradient.addColorStop(1, 'rgba(255,255,255,1)');
    } else {
      gradient.addColorStop(0, 'rgba(68,68,68,0)');
      gradient.addColorStop(0.7, 'rgba(68,68,68,0.7)');
      gradient.addColorStop(1, 'rgba(68,68,68,0.9)');
    }
    
    ctx.beginPath();
    ctx.arc(centerX, centerY, 65, 0, Math.PI * 2);
    ctx.lineWidth = 20;
    ctx.strokeStyle = gradient;
    ctx.stroke();
    
    // Inner white/black circle background
    ctx.beginPath();
    ctx.arc(centerX, centerY, 50, 0, Math.PI * 2);
    ctx.fillStyle = bgColor;
    ctx.fill();
    
    // Inner subtle ring
    ctx.beginPath();
    ctx.arc(centerX, centerY, 46, 0, Math.PI * 2);
    ctx.strokeStyle = inverted ? 'rgba(255,255,255,0.3)' : 'rgba(68,68,68,0.2)';
    ctx.lineWidth = 2;
    ctx.stroke();
    
    // Chevron/Arrow pointing up
    ctx.strokeStyle = chevronColor;
    ctx.lineWidth = 12;
    ctx.lineCap = 'round';
    ctx.lineJoin = 'round';
    
    ctx.beginPath();
    ctx.moveTo(centerX - 22, centerY + 7);
    ctx.lineTo(centerX, centerY - 15);
    ctx.lineTo(centerX + 22, centerY + 7);
    ctx.stroke();
    
    const texture = new THREE.CanvasTexture(canvas);
    texture.needsUpdate = true;
    return texture;
  };

  // Embed utilities for safe HTML/iframe rendering
  const ALLOWED_EMBED_DOMAINS = [
    'www.canva.com',
    'canva.com'
  ];

  const prepareEmbedUrl = (url) => {
    if (!url) return null;
    
    const trimmedUrl = url.trim();
    
    // If URL doesn't have ?embed, add it for Canva
    if (trimmedUrl.includes('canva.com') && !trimmedUrl.includes('?embed')) {
      return trimmedUrl + '?embed';
    }
    
    return trimmedUrl;
  };

  const isEmbedUrlSafe = (url) => {
    try {
      const urlObj = new URL(url);
      const hostname = urlObj.hostname;
      const isAllowed = ALLOWED_EMBED_DOMAINS.some(domain => 
        hostname === domain || hostname.endsWith('.' + domain)
      );
      return isAllowed;
    } catch (e) {
      console.error('URL parsing error:', e, 'URL:', url);
      return false;
    }
  };

  const ASPECT_RATIO_PRESETS = {
    '16:9': 56.25,
    '4:3': 75,
    '1:1': 100,
    'canva': 120,
    'custom': null
  };

  const EmbedModal = ({ embedConfig, onClose }) => {
    if (!embedConfig) return null;

    const embedUrl = prepareEmbedUrl(embedConfig.popupContent);
    const isSafe = embedUrl && isEmbedUrlSafe(embedUrl);

    const paddingTop = embedConfig.aspectRatio === 'custom' 
      ? embedConfig.customPadding || 100
      : ASPECT_RATIO_PRESETS[embedConfig.aspectRatio] || 56.25;

    return (
      <div 
        className="fixed inset-0 bg-black bg-opacity-75 flex items-center justify-center p-4 z-50"
        onClick={onClose}
      >
        <div 
          className="bg-white rounded-lg w-full max-w-4xl max-h-[90vh] flex flex-col"
          onClick={(e) => e.stopPropagation()}
        >
          {/* Header */}
          <div className="bg-gray-800 text-white px-6 py-4 rounded-t-lg flex justify-between items-center flex-shrink-0">
            <h2 className="text-xl font-bold">{embedConfig.popupTitle || 'Content'}</h2>
            <button 
              onClick={onClose}
              className="text-white hover:text-gray-300 transition"
            >
              <X className="w-6 h-6" />
            </button>
          </div>

          {/* Content */}
          <div className="flex-1 overflow-y-auto p-6">
            {!isSafe ? (
              <div className="text-center py-12">
                <div className="bg-red-50 border border-red-200 rounded-lg p-6 max-w-md mx-auto">
                  <X className="w-12 h-12 text-red-500 mx-auto mb-4" />
                  <h3 className="text-lg font-semibold text-red-800 mb-2">Embed Not Allowed</h3>
                  <p className="text-sm text-red-600 mb-4">
                    {embedUrl 
                      ? 'This embed URL is not from an allowed domain.'
                      : 'Please enter a valid URL.'}
                  </p>
                  {embedUrl && (
                    <div className="text-xs text-gray-700 mb-4 p-2 bg-gray-100 rounded break-all">
                      <strong>URL:</strong><br />
                      {embedUrl}
                    </div>
                  )}
                  <p className="text-xs text-gray-600">
                    <strong>Allowed domains:</strong><br />
                    {ALLOWED_EMBED_DOMAINS.join(', ')}
                  </p>
                </div>
              </div>
            ) : (
              <div className="relative w-full" style={{ paddingTop: `${paddingTop}%` }}>
                <iframe
                  src={embedUrl}
                  className="absolute top-0 left-0 w-full h-full border-0 rounded"
                  allow="fullscreen; autoplay; clipboard-write; encrypted-media; picture-in-picture"
                  allowFullScreen
                  referrerPolicy="no-referrer-when-downgrade"
                  title={embedConfig.popupTitle || 'Embedded Content'}
                />
              </div>
            )}
          </div>
        </div>
      </div>
    );
  };

  // Top HUD Display Component
  const TopHUD = ({ scene, tour, onNavigate, onPopup }) => {
    if (!scene.hudConfig?.enabled) return null;

    const { displayTitle, button1, button2, button3 } = scene.hudConfig;
    const enabledButtons = [button1, button2, button3].filter(btn => btn?.enabled);

    if (!displayTitle && enabledButtons.length === 0) return null;

    const getIconComponent = (iconName) => {
      const iconMap = {
        'Home': Home,
        'Map': Map,
        'Info': Info,
        'Video': Video,
        'Share2': Share2
      };
      return iconMap[iconName] || Home;
    };

    const handleButtonClick = (button) => {
      if (button.targetSceneId) {
        onNavigate(button.targetSceneId);
      }
    };

    const handlePopupClick = (button) => {
      if (button.popupMode === 'url' && button.popupContent) {
        window.open(button.popupContent, '_blank');
      } else if (button.popupMode === 'embed') {
        onPopup(button);
      }
    };

    return (
      <div className="absolute top-4 left-1/2 transform -translate-x-1/2 z-30">
        <div className="bg-black bg-opacity-70 backdrop-blur-sm rounded-lg shadow-2xl px-6 py-3">
          <div className="flex items-center gap-4">
            {/* Display Title */}
            {displayTitle && (
              <div className="text-white font-semibold text-lg">
                {displayTitle}
              </div>
            )}

            {/* Buttons */}
            {enabledButtons.length > 0 && (
              <div className="flex gap-2 border-l border-white border-opacity-30 pl-4">
                {button1?.enabled && (
                  <button
                    onClick={() => handleButtonClick(button1)}
                    className="flex items-center gap-2 bg-white bg-opacity-20 hover:bg-opacity-30 text-white px-4 py-2 rounded-lg transition"
                    title={button1.label}
                  >
                    {React.createElement(getIconComponent(button1.icon), { className: 'w-4 h-4' })}
                    <span className="text-sm font-medium">{button1.label}</span>
                  </button>
                )}

                {button2?.enabled && (
                  <button
                    onClick={() => handleButtonClick(button2)}
                    className="flex items-center gap-2 bg-white bg-opacity-20 hover:bg-opacity-30 text-white px-4 py-2 rounded-lg transition"
                    title={button2.label}
                  >
                    {React.createElement(getIconComponent(button2.icon), { className: 'w-4 h-4' })}
                    <span className="text-sm font-medium">{button2.label}</span>
                  </button>
                )}

                {button3?.enabled && (
                  <button
                    onClick={() => handlePopupClick(button3)}
                    className="flex items-center gap-2 bg-white bg-opacity-20 hover:bg-opacity-30 text-white px-4 py-2 rounded-lg transition"
                    title={button3.label}
                  >
                    {React.createElement(getIconComponent(button3.icon), { className: 'w-4 h-4' })}
                    <span className="text-sm font-medium">{button3.label}</span>
                  </button>
                )}
              </div>
            )}
          </div>
        </div>
      </div>
    );
  };

  // Common icon options for HUD buttons
  const HUD_ICON_OPTIONS = [
    { value: 'Home', label: 'Home' },
    { value: 'Map', label: 'Map' },
    { value: 'Info', label: 'Info' },
    { value: 'Video', label: 'Video' },
    { value: 'Share2', label: 'Share' }
  ];

  const HudEditorModal = ({ scene, tour, onClose, onSave }) => {
    const [hudConfig, setHudConfig] = useState(scene.hudConfig || {
      enabled: false,
      displayTitle: '',
      button1: null,
      button2: null,
      button3: null
    });

    return (
      <div className="bg-white rounded-lg w-full max-w-2xl flex flex-col" style={{ maxHeight: '90vh' }}>
        {/* Header */}
        <div className="bg-purple-600 text-white px-6 py-4 rounded-t-lg flex justify-between items-center flex-shrink-0">
          <h2 className="text-2xl font-bold">Top HUD Navigation</h2>
          <button onClick={onClose} className="text-white hover:text-gray-200">
            <X className="w-6 h-6" />
          </button>
        </div>

        {/* Content - Scrollable */}
        <div className="flex-1 overflow-y-auto p-6" style={{ minHeight: 0 }}>
          {/* Enable HUD Toggle */}
          <label className="flex items-center justify-between p-3 bg-gray-50 rounded-lg mb-4 cursor-pointer">
            <span className="font-medium">Enable HUD for this scene</span>
            <input
              type="checkbox"
              checked={hudConfig.enabled}
              onChange={(e) => setHudConfig({ ...hudConfig, enabled: e.target.checked })}
              className="w-5 h-5"
            />
          </label>

          {hudConfig.enabled && (
            <>
              {/* Display Title */}
              <div className="mb-4">
                <label className="block text-sm font-medium mb-2">Display Title</label>
                <input
                  type="text"
                  value={hudConfig.displayTitle || ''}
                  onChange={(e) => setHudConfig({ ...hudConfig, displayTitle: e.target.value })}
                  placeholder="Enter display title..."
                  className="w-full px-3 py-2 border rounded-lg"
                />
              </div>

              {/* Button 1 Configuration */}
              <HudButtonConfig
                buttonNum={1}
                buttonConfig={hudConfig.button1}
                buttonType="nav"
                tour={tour}
                onChange={(config) => setHudConfig({ ...hudConfig, button1: config })}
              />

              {/* Button 2 Configuration */}
              <HudButtonConfig
                buttonNum={2}
                buttonConfig={hudConfig.button2}
                buttonType="nav"
                tour={tour}
                onChange={(config) => setHudConfig({ ...hudConfig, button2: config })}
              />

              {/* Button 3 Configuration */}
              <HudButtonConfig
                buttonNum={3}
                buttonConfig={hudConfig.button3}
                buttonType="popup"
                tour={tour}
                onChange={(config) => setHudConfig({ ...hudConfig, button3: config })}
              />
            </>
          )}
        </div>

        {/* Footer */}
        <div className="border-t p-4 flex justify-end gap-2 flex-shrink-0">
          <button
            onClick={onClose}
            className="px-4 py-2 bg-gray-200 rounded hover:bg-gray-300"
          >
            Cancel
          </button>
          <button
            onClick={() => onSave(hudConfig)}
            className="px-4 py-2 bg-purple-600 text-white rounded hover:bg-purple-700"
          >
            Save Changes
          </button>
        </div>
      </div>
    );
  };

  const HudButtonConfig = ({ buttonNum, buttonConfig, buttonType, tour, onChange }) => {
    const config = buttonConfig || {
      enabled: false,
      label: '',
      icon: 'Home',
      targetSceneId: '',
      popupMode: 'url',
      popupTitle: '',
      popupContent: '',
      aspectRatio: 'canva',
      customPadding: 100
    };

    const [showPreview, setShowPreview] = useState(false);

    return (
      <div className="border rounded-lg p-4 mb-4">
        <div className="flex justify-between items-center mb-3">
          <h4 className="font-semibold">Button {buttonNum} {buttonType === 'popup' ? '(Popup)' : '(Nav)'}</h4>
          <label className="flex items-center cursor-pointer">
            <span className="text-sm mr-2">Enabled</span>
            <input
              type="checkbox"
              checked={config.enabled}
              onChange={(e) => onChange({ ...config, enabled: e.target.checked })}
              className="w-4 h-4"
            />
          </label>
        </div>

        {config.enabled && (
          <div className="space-y-3">
            {/* Label */}
            <div>
              <label className="block text-sm font-medium mb-1">Button Label</label>
              <input
                type="text"
                value={config.label}
                onChange={(e) => onChange({ ...config, label: e.target.value })}
                placeholder="e.g., Home, Map, Info..."
                className="w-full px-3 py-2 border rounded text-sm"
              />
            </div>

            {/* Icon Picker */}
            <div>
              <label className="block text-sm font-medium mb-1">Icon</label>
              <select
                value={config.icon}
                onChange={(e) => onChange({ ...config, icon: e.target.value })}
                className="w-full px-3 py-2 border rounded text-sm"
              >
                {HUD_ICON_OPTIONS.map(opt => (
                  <option key={opt.value} value={opt.value}>{opt.label}</option>
                ))}
              </select>
            </div>

            {/* Navigation Button Settings */}
            {buttonType === 'nav' && (
              <div>
                <label className="block text-sm font-medium mb-1">Target Scene</label>
                <select
                  value={config.targetSceneId}
                  onChange={(e) => onChange({ ...config, targetSceneId: e.target.value })}
                  className="w-full px-3 py-2 border rounded text-sm"
                >
                  <option value="">Select a scene...</option>
                  {tour.scenes.map(scene => (
                    <option key={scene.id} value={scene.id}>{scene.name}</option>
                  ))}
                </select>
              </div>
            )}

            {/* Popup Button Settings */}
            {buttonType === 'popup' && (
              <>
                <div>
                  <label className="block text-sm font-medium mb-1">Popup Type</label>
                  <select
                    value={config.popupMode}
                    onChange={(e) => onChange({ ...config, popupMode: e.target.value })}
                    className="w-full px-3 py-2 border rounded text-sm"
                  >
                    <option value="url">External Link</option>
                    <option value="embed">Embed (Canva)</option>
                  </select>
                </div>

                <div>
                  <label className="block text-sm font-medium mb-1">Popup Title</label>
                  <input
                    type="text"
                    value={config.popupTitle}
                    onChange={(e) => onChange({ ...config, popupTitle: e.target.value })}
                    placeholder="Popup title..."
                    className="w-full px-3 py-2 border rounded text-sm"
                  />
                </div>

                {config.popupMode === 'url' && (
                  <div>
                    <label className="block text-sm font-medium mb-1">URL</label>
                    <input
                      type="url"
                      value={config.popupContent}
                      onChange={(e) => onChange({ ...config, popupContent: e.target.value })}
                      placeholder="https://example.com"
                      className="w-full px-3 py-2 border rounded text-sm"
                    />
                  </div>
                )}

                {config.popupMode === 'embed' && (
                  <>
                    <div>
                      <label className="block text-sm font-medium mb-1">Embed URL</label>
                      <input
                        type="url"
                        value={config.popupContent}
                        onChange={(e) => onChange({ ...config, popupContent: e.target.value })}
                        placeholder="https://www.canva.com/design/.../view"
                        className="w-full px-3 py-2 border rounded text-sm"
                      />
                      <p className="text-xs text-gray-500 mt-1">
                        Paste your Canva "Smart Embed Link" (automatically adds ?embed)
                      </p>
                    </div>

                    <div>
                      <label className="block text-sm font-medium mb-1">Aspect Ratio</label>
                      <select
                        value={config.aspectRatio || 'canva'}
                        onChange={(e) => onChange({ ...config, aspectRatio: e.target.value })}
                        className="w-full px-3 py-2 border rounded text-sm"
                      >
                        <option value="canva">Canva Default (120%)</option>
                        <option value="16:9">16:9 (Widescreen)</option>
                        <option value="4:3">4:3 (Standard)</option>
                        <option value="1:1">1:1 (Square)</option>
                        <option value="custom">Custom</option>
                      </select>
                    </div>

                    {config.aspectRatio === 'custom' && (
                      <div>
                        <label className="block text-sm font-medium mb-1">Custom Padding-Top %</label>
                        <input
                          type="number"
                          value={config.customPadding || 100}
                          onChange={(e) => onChange({ ...config, customPadding: parseFloat(e.target.value) || 100 })}
                          placeholder="100"
                          min="10"
                          max="300"
                          className="w-full px-3 py-2 border rounded text-sm"
                        />
                      </div>
                    )}

                    {/* Preview Button */}
                    {config.popupContent && (
                      <div>
                        <button
                          type="button"
                          onClick={() => setShowPreview(!showPreview)}
                          className="text-sm text-blue-600 hover:text-blue-800 font-medium"
                        >
                          {showPreview ? 'Hide Preview' : 'Show Preview'}
                        </button>
                        
                        {showPreview && (
                          <div className="mt-2 border rounded-lg p-3 bg-gray-50">
                            <p className="text-xs text-gray-600 mb-2">Preview:</p>
                            {(() => {
                              const embedUrl = prepareEmbedUrl(config.popupContent);
                              const isSafe = embedUrl && isEmbedUrlSafe(embedUrl);
                              
                              if (!embedUrl) {
                                return (
                                  <div className="text-xs text-red-600 bg-red-50 p-2 rounded">
                                    ⚠️ Please enter a valid URL
                                  </div>
                                );
                              }
                              
                              if (!isSafe) {
                                return (
                                  <div className="text-xs bg-red-50 p-2 rounded">
                                    <div className="text-red-600 mb-2">
                                      ⚠️ URL not from allowed domain
                                    </div>
                                    <div className="text-gray-700 mb-2 break-all">
                                      <strong>URL:</strong> {embedUrl}
                                    </div>
                                    <div className="text-gray-600">
                                      <strong>Allowed:</strong> {ALLOWED_EMBED_DOMAINS.join(', ')}
                                    </div>
                                  </div>
                                );
                              }
                              
                              const paddingTop = config.aspectRatio === 'custom'
                                ? config.customPadding || 100
                                : ASPECT_RATIO_PRESETS[config.aspectRatio || 'canva'];
                              
                              return (
                                <div className="relative w-full" style={{ paddingTop: `${paddingTop}%` }}>
                                  <iframe
                                    src={embedUrl}
                                    className="absolute top-0 left-0 w-full h-full border-0 rounded"
                                    allow="fullscreen"
                                    title="Preview"
                                  />
                                </div>
                              );
                            })()}
                          </div>
                        )}
                      </div>
                    )}
                  </>
                )}
              </>
            )}
          </div>
        )}
      </div>
    );
  };

  // LocationPicker Component - Modal map for setting scene location
  const LocationPicker = ({ currentLocation, onSave, onClose }) => {
    const mapContainerRef = useRef(null);
    const mapRef = useRef(null);
    const markerRef = useRef(null);
    const [mapboxLoaded, setMapboxLoaded] = useState(false);
    const [loadError, setLoadError] = useState(false);
    const [selectedLocation, setSelectedLocation] = useState(currentLocation || { lat: 32.8998, lng: -106.9120 });

    // Load Mapbox GL JS dynamically
    useEffect(() => {
      if (window.mapboxgl) {
        setMapboxLoaded(true);
        return;
      }

      const link = document.createElement('link');
      link.href = 'https://api.mapbox.com/mapbox-gl-js/v3.0.1/mapbox-gl.css';
      link.rel = 'stylesheet';
      document.head.appendChild(link);

      const script = document.createElement('script');
      script.src = 'https://api.mapbox.com/mapbox-gl-js/v3.0.1/mapbox-gl.js';
      script.onload = () => {
        console.log('Mapbox GL loaded for LocationPicker');
        setMapboxLoaded(true);
      };
      script.onerror = () => {
        console.error('Failed to load Mapbox GL for LocationPicker');
        setLoadError(true);
      };
      document.head.appendChild(script);

      // Timeout fallback
      const timeout = setTimeout(() => {
        if (!window.mapboxgl) {
          console.error('Mapbox GL loading timeout');
          setLoadError(true);
        }
      }, 10000);

      return () => {
        clearTimeout(timeout);
        if (link.parentNode) link.parentNode.removeChild(link);
        if (script.parentNode) script.parentNode.removeChild(script);
      };
    }, []);

    // Initialize map
    useEffect(() => {
      if (!mapboxLoaded || !mapContainerRef.current || mapRef.current) return;

      try {
        window.mapboxgl.accessToken = MAPBOX_TOKEN;
        const map = new window.mapboxgl.Map({
          container: mapContainerRef.current,
          style: 'mapbox://styles/mapbox/streets-v12',
          center: [selectedLocation.lng, selectedLocation.lat],
          zoom: 14
        });

        map.addControl(new window.mapboxgl.NavigationControl());

        map.on('load', () => {
          console.log('LocationPicker map loaded successfully');
        });

        // Add marker
        const el = document.createElement('div');
        el.className = 'location-marker';
        el.style.cssText = `
          width: 40px;
          height: 40px;
          background-color: #3B82F6;
          border: 3px solid white;
          border-radius: 50%;
          box-shadow: 0 4px 12px rgba(0,0,0,0.4);
          cursor: pointer;
        `;

        const marker = new window.mapboxgl.Marker({ element: el, draggable: true })
          .setLngLat([selectedLocation.lng, selectedLocation.lat])
          .addTo(map);

        marker.on('dragend', () => {
          const lngLat = marker.getLngLat();
          setSelectedLocation({ lat: lngLat.lat, lng: lngLat.lng });
        });

        markerRef.current = marker;

        // Click to set location
        map.on('click', (e) => {
          const { lng, lat } = e.lngLat;
          setSelectedLocation({ lat, lng });
          marker.setLngLat([lng, lat]);
        });

        mapRef.current = map;

        return () => {
          if (mapRef.current) {
            mapRef.current.remove();
            mapRef.current = null;
          }
        };
      } catch (error) {
        console.error('Error initializing LocationPicker map:', error);
        setLoadError(true);
      }
    }, [mapboxLoaded]);

    if (loadError) {
      return (
        <div className="fixed inset-0 bg-black bg-opacity-75 flex items-center justify-center z-50">
          <div className="bg-white rounded-lg p-6 max-w-md text-center">
            <X className="w-16 h-16 text-red-600 mx-auto mb-4" />
            <h3 className="text-xl font-bold mb-2">Map Failed to Load</h3>
            <p className="text-gray-600 mb-4">
              The map cannot load in the Claude.ai artifact environment due to security restrictions.
            </p>
            <p className="text-sm text-gray-500 mb-4">
              To use the map feature, download the app and run it on your own domain.
            </p>
            <button
              onClick={onClose}
              className="px-6 py-2 bg-blue-600 text-white rounded-lg hover:bg-blue-700"
            >
              Close
            </button>
          </div>
        </div>
      );
    }

    if (!mapboxLoaded) {
      return (
        <div className="fixed inset-0 bg-black bg-opacity-75 flex items-center justify-center z-50">
          <div className="bg-white rounded-lg p-6 text-center">
            <div className="animate-spin rounded-full h-12 w-12 border-b-2 border-blue-600 mx-auto mb-4"></div>
            <div className="text-lg mb-4">Loading map...</div>
            <button
              onClick={onClose}
              className="px-4 py-2 bg-gray-300 text-gray-700 rounded-lg hover:bg-gray-400"
            >
              Cancel
            </button>
          </div>
        </div>
      );
    }

    return (
      <div className="fixed inset-0 bg-black bg-opacity-75 flex items-center justify-center z-50">
        <div className="bg-white rounded-lg shadow-2xl w-full max-w-4xl max-h-[90vh] flex flex-col">
          {/* Header */}
          <div className="bg-blue-600 text-white px-6 py-4 rounded-t-lg flex justify-between items-center">
            <h2 className="text-xl font-bold">Set Scene Location on Map</h2>
            <button
              onClick={onClose}
              className="text-white hover:text-gray-200"
            >
              <X className="w-6 h-6" />
            </button>
          </div>

          {/* Map */}
          <div ref={mapContainerRef} className="flex-1" style={{ minHeight: '400px' }} />

          {/* Coordinates Display & Actions */}
          <div className="px-6 py-4 bg-gray-50 rounded-b-lg">
            <div className="mb-4">
              <p className="text-sm text-gray-600 mb-2">Click on the map or drag the marker to set location</p>
              <div className="flex gap-4 text-sm">
                <div>
                  <span className="font-medium text-gray-700">Latitude:</span> {selectedLocation.lat.toFixed(6)}
                </div>
                <div>
                  <span className="font-medium text-gray-700">Longitude:</span> {selectedLocation.lng.toFixed(6)}
                </div>
              </div>
            </div>
            <div className="flex gap-3">
              <button
                onClick={() => onSave(selectedLocation)}
                className="px-6 py-2 bg-blue-600 text-white rounded-lg hover:bg-blue-700 font-medium"
              >
                Save Location
              </button>
              <button
                onClick={onClose}
                className="px-6 py-2 bg-gray-300 text-gray-700 rounded-lg hover:bg-gray-400 font-medium"
              >
                Cancel
              </button>
            </div>
          </div>
        </div>
      </div>
    );
  };

  const SceneEditor = ({ scene, tour, tours, setTours, setSelectedTour, onSave, showHotspotLabels }) => {
    const [currentScene, setCurrentScene] = useState({ ...scene });
    const [hotspotType, setHotspotType] = useState(null);
    const [infoHotspotType, setInfoHotspotType] = useState(null);
    const [showHotspotForm, setShowHotspotForm] = useState(false);
    const [hotspotData, setHotspotData] = useState({});
    const [editingHotspot, setEditingHotspot] = useState(null);
    const [imageLoading, setImageLoading] = useState(true);
    const [imageError, setImageError] = useState(false);
    const [livePreviewData, setLivePreviewData] = useState(null);
    const [showViewSettings, setShowViewSettings] = useState(false);
    const [selectedViewScenes, setSelectedViewScenes] = useState({ default: true });
    const [showHudEditor, setShowHudEditor] = useState(false);
    const [showEmbedModal, setShowEmbedModal] = useState(false);
    const [embedModalConfig, setEmbedModalConfig] = useState(null);
    const [showLocationPicker, setShowLocationPicker] = useState(false);
    const viewerRef = useRef(null);
    const cameraPositionRef = useRef({ lon: 0, lat: 0 });
    const hotspotTypeRef = useRef(null);
    const infoHotspotTypeRef = useRef(null);
    const sceneRef = useRef(null);
    const hotspotObjectsRef = useRef({});
    const hotspotLabelsRef = useRef([]);

    useEffect(() => {
      hotspotTypeRef.current = hotspotType;
      infoHotspotTypeRef.current = infoHotspotType;
    }, [hotspotType, infoHotspotType]);

    useEffect(() => {
      setCurrentScene({ ...scene });
      setImageLoading(true);
      setImageError(false);
      hotspotLabelsRef.current = []; // Clear label refs
    }, [scene]);

    useEffect(() => {
      if (!viewerRef.current) return;

      const scene3d = new THREE.Scene();
      sceneRef.current = scene3d;
      const camera = new THREE.PerspectiveCamera(75, viewerRef.current.clientWidth / viewerRef.current.clientHeight, 0.1, 1000);
      const renderer = new THREE.WebGLRenderer({ antialias: true });
      
      renderer.setSize(viewerRef.current.clientWidth, viewerRef.current.clientHeight);
      viewerRef.current.innerHTML = '';
      viewerRef.current.appendChild(renderer.domElement);

      const geometry = new THREE.SphereGeometry(500, 256, 128);
      geometry.scale(-1, 1, 1);

      const material = new THREE.MeshBasicMaterial({ 
        color: 0x404040,
        side: THREE.FrontSide
      });
      const sphere = new THREE.Mesh(geometry, material);
      scene3d.add(sphere);

      const isBase64 = currentScene.imageUrl.startsWith('data:image');
      
      if (isBase64) {
        const img = document.createElement('img');
        img.onload = function() {
          const tex = new THREE.Texture(img);
          tex.minFilter = THREE.LinearFilter;
          tex.magFilter = THREE.LinearFilter;
          tex.needsUpdate = true;
          material.map = tex;
          material.color.setHex(0xffffff);
          material.needsUpdate = true;
          setImageLoading(false);
        };
        img.onerror = function() {
          setImageError(true);
          setImageLoading(false);
        };
        img.src = currentScene.imageUrl;
      } else {
        const loader = new THREE.TextureLoader();
        loader.crossOrigin = 'anonymous';
        loader.load(currentScene.imageUrl, 
          function(tex) {
            tex.minFilter = THREE.LinearFilter;
            tex.magFilter = THREE.LinearFilter;
            material.map = tex;
            material.color.setHex(0xffffff);
            material.needsUpdate = true;
            setImageLoading(false);
          },
          undefined,
          function(err) {
            console.error('Failed to load URL image:', err);
            setImageError(true);
            setImageLoading(false);
          }
        );
      }

      hotspotObjectsRef.current = {};

      currentScene.hotspots.forEach(hotspot => {
        const hotspotSize = hotspot.size || 1;
        const hotspotOpacity = (hotspot.opacity !== undefined ? hotspot.opacity : 100) / 100;
        const iconUrl = hotspot.iconUrl;

        if (iconUrl) {
          // Custom icon - use sprite with texture
          const textureLoader = new THREE.TextureLoader();
          textureLoader.crossOrigin = 'anonymous';
          textureLoader.load(
            iconUrl,
            (texture) => {
              const spriteMaterial = new THREE.SpriteMaterial({ 
                map: texture,
                sizeAttenuation: false,
                transparent: true,
                opacity: hotspotOpacity,
                depthTest: false,
                depthWrite: false
              });
              const sprite = new THREE.Sprite(spriteMaterial);
              sprite.scale.set(0.24 * hotspotSize, 0.24 * hotspotSize, 1);
              sprite.renderOrder = 999;
              sprite.position.set(hotspot.position.x, hotspot.position.y, hotspot.position.z);
              if (hotspot.rotation) {
                sprite.material.rotation = (hotspot.rotation * Math.PI) / 180;
              }
              sprite.userData = hotspot;
              scene3d.add(sprite);
              hotspotObjectsRef.current[hotspot.id] = sprite;
            },
            undefined,
            (err) => {
              console.error('Failed to load hotspot icon:', err);
              addDefaultHotspot(hotspot, hotspotSize, hotspotOpacity);
            }
          );
        } else {
          addDefaultHotspot(hotspot, hotspotSize, hotspotOpacity);
        }
      });

      function addDefaultHotspot(hotspot, size = 1, opacity = 1) {
        // Navigation hotspots use sprite with custom icon
        if (hotspot.type === 'navigation') {
          const texture = createNavigationIconTexture(hotspot.inverted || false);
          const spriteMaterial = new THREE.SpriteMaterial({ 
            map: texture,
            transparent: true,
            opacity: opacity,
            sizeAttenuation: false,  // Keep constant screen size
            depthTest: false,  // Don't clip behind geometry
            depthWrite: false
          });
          const sprite = new THREE.Sprite(spriteMaterial);
          sprite.scale.set(0.24 * size, 0.24 * size, 1);  // Larger size (was 0.08)
          sprite.renderOrder = 999;  // Render on top
          sprite.position.set(hotspot.position.x, hotspot.position.y, hotspot.position.z);
          if (hotspot.rotation) {
            sprite.material.rotation = (hotspot.rotation * Math.PI) / 180; // Convert degrees to radians
          }
          sprite.userData = hotspot;
          scene3d.add(sprite);
          hotspotObjectsRef.current[hotspot.id] = sprite;
          return;
        }
        
        // Other hotspot types use spheres
        const hotspotGeometry = new THREE.SphereGeometry(8 * size, 16, 16);
        let hotspotMaterial;
        
        if (hotspot.type === 'info') {
          hotspotMaterial = new THREE.MeshBasicMaterial({ 
            color: 0x00ff00,
            transparent: true,
            opacity: opacity
          });
        } else {
          hotspotMaterial = new THREE.MeshBasicMaterial({ 
            color: 0xff00ff,
            transparent: true,
            opacity: opacity
          });
        }

        const hotspotMesh = new THREE.Mesh(hotspotGeometry, hotspotMaterial);
        hotspotMesh.position.set(hotspot.position.x, hotspot.position.y, hotspot.position.z);
        hotspotMesh.userData = hotspot;
        scene3d.add(hotspotMesh);
        hotspotObjectsRef.current[hotspot.id] = hotspotMesh;
      }

      camera.position.set(0, 0, 0.1);

      let interacting = false;
      let mouseX = 0;
      let mouseY = 0;
      
      // Check for initial view - prioritize default, or use saved camera position
      let initialLon = 0;
      let initialLat = 0;
      
      if (currentScene.initialView?.default) {
        initialLon = currentScene.initialView.default.lon;
        initialLat = currentScene.initialView.default.lat;
      } else {
        initialLon = cameraPositionRef.current.lon;
        initialLat = cameraPositionRef.current.lat;
      }
      
      let lon = initialLon;
      let lonOnDown = 0;
      let lat = initialLat;
      let latOnDown = 0;
      
      // Inertia/momentum variables
      let velLon = 0;
      let velLat = 0;
      let lastMoveX = 0;
      let lastMoveY = 0;
      let lastMoveTime = Date.now();

      // Update ref with initial or saved position
      cameraPositionRef.current = { lon, lat };

      const handlePointerDown = (event) => {
        interacting = true;
        mouseX = event.clientX;
        mouseY = event.clientY;
        lonOnDown = lon;
        latOnDown = lat;
        // Reset velocity on new interaction
        velLon = 0;
        velLat = 0;
        lastMoveX = event.clientX;
        lastMoveY = event.clientY;
        lastMoveTime = Date.now();
      };

      const handlePointerMove = (event) => {
        if (interacting) {
          const currentTime = Date.now();
          const deltaTime = Math.max(currentTime - lastMoveTime, 1); // Avoid division by zero
          
          // Calculate movement
          const deltaX = event.clientX - lastMoveX;
          const deltaY = event.clientY - lastMoveY;
          
          // Calculate velocity (pixels per millisecond)
          velLon = -(deltaX / deltaTime) * 0.15; // Negative for correct direction
          velLat = (deltaY / deltaTime) * 0.15;
          
          // Apply movement
          lon = (mouseX - event.clientX) * 0.15 + lonOnDown;
          lat = (event.clientY - mouseY) * 0.15 + latOnDown;
          cameraPositionRef.current = { lon, lat };
          
          // Update last position and time
          lastMoveX = event.clientX;
          lastMoveY = event.clientY;
          lastMoveTime = currentTime;
        }
      };

      const handlePointerUp = () => {
        interacting = false;
        // Clamp initial velocity to prevent excessive spinning
        const maxVel = 2.0;
        velLon = Math.max(-maxVel, Math.min(maxVel, velLon));
        velLat = Math.max(-maxVel * 0.5, Math.min(maxVel * 0.5, velLat)); // Weaker vertical
      };

      const handleClick = (event) => {
        const currentHotspotType = hotspotTypeRef.current;
        const currentInfoHotspotType = infoHotspotTypeRef.current;
        
        if (currentHotspotType) {
          // For info hotspots, only place if a subtype is selected
          if (currentHotspotType === 'info' && !currentInfoHotspotType) {
            return;
          }
          
          const rect = renderer.domElement.getBoundingClientRect();
          const x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
          const y = -((event.clientY - rect.top) / rect.height) * 2 + 1;

          const raycaster = new THREE.Raycaster();
          raycaster.setFromCamera({ x, y }, camera);
          const intersects = raycaster.intersectObjects([sphere]);

          if (intersects.length > 0) {
            const point = intersects[0].point;
            setHotspotData({ position: { x: point.x, y: point.y, z: point.z } });
            setShowHotspotForm(true);
          }
        }
      };

      renderer.domElement.addEventListener('pointerdown', handlePointerDown);
      renderer.domElement.addEventListener('pointermove', handlePointerMove);
      renderer.domElement.addEventListener('pointerup', handlePointerUp);
      renderer.domElement.addEventListener('click', handleClick);

      const animate = () => {
        requestAnimationFrame(animate);
        
        // Apply inertia when not interacting
        if (!interacting) {
          // Apply velocity to rotation
          lon += velLon;
          lat += velLat;
          
          // Apply friction (0.92 = subtle slow down)
          const friction = 0.92;
          velLon *= friction;
          velLat *= friction;
          
          // Stop completely when velocity is very small
          if (Math.abs(velLon) < 0.01) velLon = 0;
          if (Math.abs(velLat) < 0.01) velLat = 0;
        }
        
        lat = Math.max(-85, Math.min(85, lat));
        cameraPositionRef.current = { lon, lat };
        const phi = THREE.MathUtils.degToRad(90 - lat);
        const theta = THREE.MathUtils.degToRad(lon);
        const target = new THREE.Vector3(
          500 * Math.sin(phi) * Math.cos(theta),
          500 * Math.cos(phi),
          500 * Math.sin(phi) * Math.sin(theta)
        );
        camera.lookAt(target);
        
        // Update hotspot label positions
        if (showHotspotLabels && hotspotLabelsRef.current.length > 0 && viewerRef.current) {
          let labelIndex = 0;
          currentScene.hotspots.forEach((hotspot) => {
            if (hotspot.showLabel === false) return; // Skip hotspots with labels disabled
            
            const labelElement = hotspotLabelsRef.current[labelIndex];
            if (labelElement) {
              const vector = new THREE.Vector3(
                hotspot.position.x,
                hotspot.position.y + 15, // Offset above hotspot
                hotspot.position.z
              );
              vector.project(camera);
              
              const x = (vector.x * 0.5 + 0.5) * viewerRef.current.clientWidth;
              const y = (vector.y * -0.5 + 0.5) * viewerRef.current.clientHeight;
              
              // Check if behind camera
              const isBehind = vector.z > 1;
              
              labelElement.style.left = `${x}px`;
              labelElement.style.top = `${y}px`;
              labelElement.style.display = isBehind ? 'none' : 'block';
            }
            labelIndex++;
          });
        }
        
        renderer.render(scene3d, camera);
      };

      animate();

      const handleResize = () => {
        if (!viewerRef.current) return;
        camera.aspect = viewerRef.current.clientWidth / viewerRef.current.clientHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(viewerRef.current.clientWidth, viewerRef.current.clientHeight);
      };

      window.addEventListener('resize', handleResize);
      
      // Add ResizeObserver to handle container size changes (e.g., sidebar collapse)
      const resizeObserver = new ResizeObserver(() => {
        handleResize();
      });
      resizeObserver.observe(viewerRef.current);

      return () => {
        window.removeEventListener('resize', handleResize);
        resizeObserver.disconnect();
        renderer.domElement.removeEventListener('pointerdown', handlePointerDown);
        renderer.domElement.removeEventListener('pointermove', handlePointerMove);
        renderer.domElement.removeEventListener('pointerup', handlePointerUp);
        renderer.domElement.removeEventListener('click', handleClick);
        if (viewerRef.current) {
          viewerRef.current.innerHTML = '';
        }
      };
    }, [currentScene]);

    const addHotspot = (formData, createReturnLink = false) => {
      let updatedScene;
      let newHotspot;
      
      if (editingHotspot) {
        updatedScene = {
          ...currentScene,
          hotspots: currentScene.hotspots.map(h => 
            h.id === editingHotspot.id 
              ? { ...h, ...formData, size: formData.size || 1, opacity: formData.opacity !== undefined ? formData.opacity : 100 }
              : h
          )
        };
      } else {
        newHotspot = {
          id: Date.now().toString(),
          type: hotspotType === 'info' ? infoHotspotType : hotspotType,
          position: hotspotData.position,
          size: formData.size || 1,
          opacity: formData.opacity !== undefined ? formData.opacity : 100,
          ...formData
        };
        updatedScene = {
          ...currentScene,
          hotspots: [...currentScene.hotspots, newHotspot]
        };
      }

      setCurrentScene(updatedScene);
      
      // Handle return link creation
      if (createReturnLink && newHotspot && newHotspot.type === 'navigation' && formData.targetScene) {
        // First, update the current scene in the tour
        const tourWithCurrentScene = {
          ...tour,
          scenes: tour.scenes.map(s => s.id === currentScene.id ? updatedScene : s)
        };
        
        const targetScene = tourWithCurrentScene.scenes.find(s => s.id === formData.targetScene);
        if (targetScene) {
          // Check if return link already exists
          const existingReturnLink = targetScene.hotspots.find(
            h => h.type === 'navigation' && h.targetScene === currentScene.id
          );
          
          const createReturn = () => {
            // Calculate opposite position (flip x and z, keep y)
            const oppositePosition = {
              x: -hotspotData.position.x,
              y: hotspotData.position.y,
              z: -hotspotData.position.z
            };
            
            const returnHotspot = {
              id: Date.now().toString() + '-return',
              type: 'navigation',
              position: oppositePosition,
              targetScene: currentScene.id,
              size: formData.size || 1,
              opacity: formData.opacity !== undefined ? formData.opacity : 100,
              rotation: formData.rotation || 0,
              inverted: formData.inverted,
              iconUrl: formData.iconUrl,
              showLabel: formData.showLabel !== undefined ? formData.showLabel : true
            };
            
            const updatedTargetScene = {
              ...targetScene,
              hotspots: [...targetScene.hotspots, returnHotspot]
            };
            
            // Update the tour with BOTH scenes
            const finalTour = {
              ...tourWithCurrentScene,
              scenes: tourWithCurrentScene.scenes.map(s => 
                s.id === targetScene.id ? updatedTargetScene : s
              )
            };
            
            setTours(tours.map(t => t.id === tour.id ? finalTour : t));
            setSelectedTour(finalTour);
            // Update current scene state so the new hotspot shows immediately
            setCurrentScene(updatedScene);
            setSelectedScene(updatedScene);
            // DON'T call onSave here - we've already updated everything ourselves
          };
          
          if (existingReturnLink) {
            // Ask user for confirmation
            if (window.confirm(`A hotspot linking back to "${currentScene.name}" already exists in scene "${targetScene.name}". Create another one anyway?`)) {
              createReturn();
            } else {
              onSave(updatedScene); // Still save the current hotspot
            }
          } else {
            createReturn();
          }
        } else {
          onSave(updatedScene);
        }
      } else {
        onSave(updatedScene);
      }
      
      setHotspotType(null);
      setInfoHotspotType(null);
      setHotspotData({});
      setEditingHotspot(null);
      setShowHotspotForm(false);
      setLivePreviewData(null);
    };

    const editHotspot = (hotspot) => {
      setEditingHotspot(hotspot);
      if (hotspot.type === 'info' || hotspot.type === 'media') {
        setHotspotType('info');
        setInfoHotspotType(hotspot.type);
      } else {
        setHotspotType(hotspot.type);
      }
      setShowHotspotForm(true);
    };

    const deleteHotspot = (hotspotId) => {
      const updatedScene = {
        ...currentScene,
        hotspots: currentScene.hotspots.filter(h => h.id !== hotspotId)
      };
      setCurrentScene(updatedScene);
      onSave(updatedScene);
    };

    const handleLiveUpdate = (previewData) => {
      setLivePreviewData(previewData);
      
      // Update the hotspot in the Three.js scene in real-time
      const hotspotId = editingHotspot?.id || 'temp-preview';
      const hotspotObject = hotspotObjectsRef.current[editingHotspot?.id];
      
      if (hotspotObject && sceneRef.current) {
        const size = previewData.size || 1;
        const opacity = (previewData.opacity !== undefined ? previewData.opacity : 100) / 100;
        
        // Update sprite or mesh
        if (hotspotObject.isSprite) {
          hotspotObject.scale.set(0.24 * size, 0.24 * size, 1);
          if (hotspotObject.material) {
            hotspotObject.material.opacity = opacity;
            // Update rotation
            if (previewData.rotation !== undefined) {
              hotspotObject.material.rotation = (previewData.rotation * Math.PI) / 180;
            }
          }
          
          // If icon URL changed, reload texture
          if (previewData.iconUrl !== editingHotspot?.iconUrl) {
            if (previewData.iconUrl) {
              const textureLoader = new THREE.TextureLoader();
              textureLoader.crossOrigin = 'anonymous';
              textureLoader.load(previewData.iconUrl, (texture) => {
                hotspotObject.material.map = texture;
                hotspotObject.material.needsUpdate = true;
              });
            } else {
              // Switch to default (could be navigation icon or sphere)
              sceneRef.current.remove(hotspotObject);
              delete hotspotObjectsRef.current[editingHotspot.id];
              
              if (editingHotspot.type === 'navigation') {
                // Use navigation icon
                const texture = createNavigationIconTexture(previewData.inverted || false);
                const spriteMaterial = new THREE.SpriteMaterial({ 
                  map: texture,
                  transparent: true,
                  opacity: opacity,
                  sizeAttenuation: false,
                  depthTest: false,
                  depthWrite: false
                });
                const sprite = new THREE.Sprite(spriteMaterial);
                sprite.scale.set(0.24 * size, 0.24 * size, 1);
                sprite.renderOrder = 999;
                sprite.position.copy(hotspotObject.position);
                if (previewData.rotation) {
                  sprite.material.rotation = (previewData.rotation * Math.PI) / 180;
                }
                sprite.userData = editingHotspot;
                sceneRef.current.add(sprite);
                hotspotObjectsRef.current[editingHotspot.id] = sprite;
              } else {
                // Use colored sphere for info/media
                const hotspotGeometry = new THREE.SphereGeometry(8 * size, 16, 16);
                let color = 0x00ff00;
                if (editingHotspot.type === 'media') color = 0xff00ff;
                
                const hotspotMaterial = new THREE.MeshBasicMaterial({ 
                  color: color,
                  transparent: true,
                  opacity: opacity
                });
                const hotspotMesh = new THREE.Mesh(hotspotGeometry, hotspotMaterial);
                hotspotMesh.position.copy(hotspotObject.position);
                hotspotMesh.userData = editingHotspot;
                sceneRef.current.add(hotspotMesh);
                hotspotObjectsRef.current[editingHotspot.id] = hotspotMesh;
              }
            }
          }
          
          // Handle inverted color change for navigation icons - recreate sprite
          if (editingHotspot.type === 'navigation' && !previewData.iconUrl && hotspotObject.isSprite) {
            const currentInverted = editingHotspot?.inverted || false;
            const newInverted = previewData.inverted !== undefined ? previewData.inverted : false;
            
            if (currentInverted !== newInverted) {
              // Remove old sprite
              const oldPosition = hotspotObject.position.clone();
              sceneRef.current.remove(hotspotObject);
              if (hotspotObject.material && hotspotObject.material.map) {
                hotspotObject.material.map.dispose();
              }
              if (hotspotObject.material) {
                hotspotObject.material.dispose();
              }
              
              // Create new sprite with new color
              const texture = createNavigationIconTexture(newInverted);
              const spriteMaterial = new THREE.SpriteMaterial({ 
                map: texture,
                transparent: true,
                opacity: opacity,
                sizeAttenuation: false,
                depthTest: false,
                depthWrite: false
              });
              const sprite = new THREE.Sprite(spriteMaterial);
              sprite.scale.set(0.24 * size, 0.24 * size, 1);
              sprite.renderOrder = 999;
              sprite.position.copy(oldPosition);
              if (previewData.rotation) {
                sprite.material.rotation = (previewData.rotation * Math.PI) / 180;
              }
              sprite.userData = { ...editingHotspot, inverted: newInverted };
              sceneRef.current.add(sprite);
              hotspotObjectsRef.current[editingHotspot.id] = sprite;
            }
          }
        } else {
          // It's a mesh (sphere)
          hotspotObject.scale.set(size, size, size);
          if (hotspotObject.material) {
            hotspotObject.material.opacity = opacity;
            hotspotObject.material.transparent = true;
          }
          
          // If icon URL is now set, switch to sprite
          if (previewData.iconUrl && !editingHotspot?.iconUrl) {
            const textureLoader = new THREE.TextureLoader();
            textureLoader.crossOrigin = 'anonymous';
            textureLoader.load(previewData.iconUrl, (texture) => {
              sceneRef.current.remove(hotspotObject);
              delete hotspotObjectsRef.current[editingHotspot.id];
              
              const spriteMaterial = new THREE.SpriteMaterial({ 
                map: texture,
                sizeAttenuation: false,
                transparent: true,
                opacity: opacity,
                depthTest: false,
                depthWrite: false
              });
              const sprite = new THREE.Sprite(spriteMaterial);
              sprite.scale.set(0.24 * size, 0.24 * size, 1);
              sprite.renderOrder = 999;
              sprite.position.copy(hotspotObject.position);
              if (previewData.rotation) {
                sprite.material.rotation = (previewData.rotation * Math.PI) / 180;
              }
              sprite.userData = editingHotspot;
              sceneRef.current.add(sprite);
              hotspotObjectsRef.current[editingHotspot.id] = sprite;
            });
          }
        }
      }
    };

    return (
      <div className="h-full flex flex-col">
        <div className="bg-gray-800 text-white px-4 py-3 flex justify-between items-center">
          <h3 className="text-lg font-semibold">{currentScene.name}</h3>
        </div>

        <div className="flex-1 relative">
          <div 
            ref={viewerRef} 
            className={`w-full h-full ${hotspotType ? 'cursor-crosshair' : ''}`}
          />
          
          {imageLoading && (
            <div className="absolute inset-0 flex items-center justify-center bg-black bg-opacity-75">
              <div className="text-white text-center">
                <div className="animate-spin rounded-full h-12 w-12 border-b-2 border-white mx-auto mb-4"></div>
                <p>Loading 360° image...</p>
              </div>
            </div>
          )}

          {imageError && (
            <div className="absolute inset-0 flex items-center justify-center bg-red-900 bg-opacity-90">
              <div className="text-white text-center max-w-md mx-4">
                <X className="w-16 h-16 mx-auto mb-4" />
                <h3 className="text-xl font-bold mb-2">Failed to Load Image</h3>
                <p className="mb-4">The image URL might be incorrect or blocked.</p>
                <p className="text-sm">Try using a direct image link from Imgur.</p>
              </div>
            </div>
          )}
          
          {!imageLoading && !imageError && hotspotType && (
            <div className="absolute top-4 left-1/2 transform -translate-x-1/2 bg-yellow-500 text-black px-6 py-3 rounded-lg shadow-lg font-medium">
              Click anywhere on the 360° image to place your hotspot
            </div>
          )}

          {/* Top HUD Display */}
          {!imageLoading && !imageError && !hotspotType && (
            <TopHUD
              scene={currentScene}
              tour={tour}
              onNavigate={(sceneId) => {
                const targetScene = tour.scenes.find(s => s.id === sceneId);
                if (targetScene) {
                  setCurrentScene(targetScene);
                  setSelectedScene(targetScene);
                }
              }}
              onPopup={(button) => {
                setEmbedModalConfig(button);
                setShowEmbedModal(true);
              }}
            />
          )}

          {/* Embed Modal */}
          {showEmbedModal && embedModalConfig && (
            <EmbedModal
              embedConfig={embedModalConfig}
              onClose={() => {
                setShowEmbedModal(false);
                setEmbedModalConfig(null);
              }}
            />
          )}

          {/* Hotspot Buttons - Bottom Right */}
          <div className="absolute bottom-4 right-4 flex flex-col gap-2">
            {/* Set Initial View Button with 3-dot menu */}
            <div className="flex gap-1">
              <button
                onClick={() => {
                  // Quick save to default
                  const currentView = {
                    lon: cameraPositionRef.current.lon,
                    lat: cameraPositionRef.current.lat
                  };
                  const updatedScene = {
                    ...currentScene,
                    initialView: {
                      ...currentScene.initialView,
                      default: currentView
                    }
                  };
                  setCurrentScene(updatedScene);
                  onSave(updatedScene);
                }}
                className="flex-1 px-4 py-3 rounded-lg flex items-center shadow-lg bg-white text-gray-800 hover:bg-gray-100 transition"
              >
                {currentScene.initialView?.default && (
                  <span className="text-green-600 mr-2">✓</span>
                )}
                <Camera className="w-5 h-5 mr-2" />
                <span className="font-medium">Set Initial View</span>
              </button>
              
              {/* 3-dot menu button */}
              <button
                onClick={() => setShowViewSettings(!showViewSettings)}
                className="px-3 py-3 rounded-lg shadow-lg bg-white text-gray-800 hover:bg-gray-100 transition"
                title="Advanced view settings"
              >
                <span className="text-lg font-bold">⋯</span>
              </button>
            </div>

            {/* View Settings Panel */}
            {showViewSettings && (
              <div className="bg-white rounded-lg shadow-2xl p-4 max-h-80 overflow-y-auto border border-gray-200 mb-2">
                <h4 className="font-semibold text-gray-800 mb-3 text-sm">Set View When Entering From:</h4>
                
                {/* Default view checkbox */}
                <label className="flex items-center mb-3 cursor-pointer hover:bg-gray-50 p-2 rounded">
                  <input
                    type="checkbox"
                    checked={selectedViewScenes.default || false}
                    onChange={(e) => setSelectedViewScenes({
                      ...selectedViewScenes,
                      default: e.target.checked
                    })}
                    className="mr-3 w-4 h-4"
                  />
                  <span className="font-medium text-gray-700">Default (Any Scene)</span>
                </label>

                <div className="border-t pt-3 mb-2">
                  <p className="text-xs text-gray-500 mb-2">Specific Scenes:</p>
                </div>

                {/* Other scenes checkboxes */}
                {tour.scenes.filter(s => s.id !== currentScene.id).map(scene => (
                  <label key={scene.id} className="flex items-center mb-2 cursor-pointer hover:bg-gray-50 p-2 rounded">
                    <input
                      type="checkbox"
                      checked={selectedViewScenes[scene.id] || false}
                      onChange={(e) => setSelectedViewScenes({
                        ...selectedViewScenes,
                        [scene.id]: e.target.checked
                      })}
                      className="mr-3 w-4 h-4"
                    />
                    <span className="text-sm text-gray-700">{scene.name}</span>
                  </label>
                ))}

                {/* Save button */}
                <button
                  onClick={() => {
                    const currentView = {
                      lon: cameraPositionRef.current.lon,
                      lat: cameraPositionRef.current.lat
                    };
                    
                    const newInitialView = { ...currentScene.initialView };
                    
                    // Save to default if checked
                    if (selectedViewScenes.default) {
                      newInitialView.default = currentView;
                    }
                    
                    // Save to fromScenes
                    if (!newInitialView.fromScenes) {
                      newInitialView.fromScenes = {};
                    }
                    
                    // Update only selected scenes
                    Object.keys(selectedViewScenes).forEach(key => {
                      if (key !== 'default' && selectedViewScenes[key]) {
                        newInitialView.fromScenes[key] = currentView;
                      }
                    });
                    
                    const updatedScene = {
                      ...currentScene,
                      initialView: newInitialView
                    };
                    
                    setCurrentScene(updatedScene);
                    onSave(updatedScene);
                    setShowViewSettings(false);
                    setSelectedViewScenes({ default: true }); // Reset selection
                  }}
                  className="w-full bg-blue-600 text-white py-2 rounded-lg hover:bg-blue-700 font-medium mt-3"
                >
                  Save View Settings
                </button>

                <button
                  onClick={() => {
                    setShowViewSettings(false);
                    setSelectedViewScenes({ default: true });
                  }}
                  className="w-full bg-gray-200 text-gray-700 py-2 rounded-lg hover:bg-gray-300 font-medium mt-2"
                >
                  Cancel
                </button>

                {/* Reset All Views Button - Inside the menu */}
                {currentScene.initialView && (
                  <>
                    <div className="border-t mt-3 pt-3">
                      <p className="text-xs text-gray-500 mb-2">Danger Zone:</p>
                    </div>
                    <button
                      onClick={() => {
                        if (window.confirm('Are you sure you want to reset all view settings for this scene? This will remove the default view and all scene-specific views.')) {
                          const updatedScene = {
                            ...currentScene,
                            initialView: null
                          };
                          setCurrentScene(updatedScene);
                          onSave(updatedScene);
                          setShowViewSettings(false);
                        }
                      }}
                      className="w-full bg-red-50 text-red-600 py-2 rounded-lg hover:bg-red-100 font-medium flex items-center justify-center"
                    >
                      <X className="w-4 h-4 mr-1" />
                      Reset All Views
                    </button>
                  </>
                )}
              </div>
            )}

            {/* Top HUD Editor Panel */}
            {showHudEditor && (
              <div className="fixed inset-0 bg-black bg-opacity-75 flex items-center justify-center p-4 z-50">
                <HudEditorModal
                  scene={currentScene}
                  tour={tour}
                  onClose={() => setShowHudEditor(false)}
                  onSave={(hudConfig) => {
                    const updatedScene = {
                      ...currentScene,
                      hudConfig: hudConfig
                    };
                    setCurrentScene(updatedScene);
                    onSave(updatedScene);
                    setShowHudEditor(false);
                  }}
                />
              </div>
            )}

            {/* Location Picker Modal */}
            {showLocationPicker && (
              <LocationPicker
                currentLocation={currentScene.location}
                onSave={(location) => {
                  const updatedScene = {
                    ...currentScene,
                    location: location
                  };
                  setCurrentScene(updatedScene);
                  onSave(updatedScene);
                  setShowLocationPicker(false);
                }}
                onClose={() => setShowLocationPicker(false)}
              />
            )}

            <button
              onClick={() => {
                setHotspotType(hotspotType === 'navigation' ? null : 'navigation');
                setShowViewSettings(false); // Close view settings when adding hotspots
              }}
              className={`px-4 py-3 rounded-lg flex items-center shadow-lg transition ${
                hotspotType === 'navigation' 
                  ? 'bg-blue-600 text-white' 
                  : 'bg-white text-gray-800 hover:bg-gray-100'
              }`}
            >
              <Navigation className="w-5 h-5 mr-2" />
              <span className="font-medium">Link Scene</span>
            </button>
            
            <button
              onClick={() => setShowHudEditor(!showHudEditor)}
              className={`px-4 py-3 rounded-lg flex items-center shadow-lg transition ${
                showHudEditor
                  ? 'bg-purple-600 text-white' 
                  : 'bg-white text-gray-800 hover:bg-gray-100'
              }`}
            >
              <Info className="w-5 h-5 mr-2" />
              <span className="font-medium">Top HUD</span>
            </button>
            
            <button
              onClick={() => setShowLocationPicker(true)}
              className={`px-4 py-3 rounded-lg flex items-center shadow-lg transition ${
                currentScene.location?.lat && currentScene.location?.lng
                  ? 'bg-blue-600 text-white' 
                  : 'bg-white text-gray-800 hover:bg-gray-100'
              }`}
            >
              {currentScene.location?.lat && currentScene.location?.lng && (
                <span className="text-green-300 mr-2">✓</span>
              )}
              <MapPin className="w-5 h-5 mr-2" />
              <span className="font-medium">Set Location</span>
            </button>
            
            <div className="relative">
              <button
                onClick={() => {
                  if (hotspotType === 'info') {
                    setHotspotType(null);
                    setInfoHotspotType(null);
                  } else {
                    setHotspotType('info');
                  }
                  setShowViewSettings(false); // Close view settings when adding hotspots
                }}
                className={`px-4 py-3 rounded-lg flex items-center shadow-lg transition w-full ${
                  hotspotType === 'info' 
                    ? 'bg-green-600 text-white' 
                    : 'bg-white text-gray-800 hover:bg-gray-100'
                }`}
              >
                <Info className="w-5 h-5 mr-2" />
                <span className="font-medium">Info Hotspot</span>
              </button>
              
              {hotspotType === 'info' && !infoHotspotType && (
                <div className="absolute bottom-full right-0 mb-2 bg-white rounded-lg shadow-xl p-2 min-w-[180px]">
                  <button
                    onClick={() => setInfoHotspotType('info')}
                    className="w-full px-4 py-2 text-left hover:bg-gray-100 rounded flex items-center"
                  >
                    <Info className="w-4 h-4 mr-2 text-green-600" />
                    <span>Info Point</span>
                  </button>
                  <button
                    onClick={() => setInfoHotspotType('media')}
                    className="w-full px-4 py-2 text-left hover:bg-gray-100 rounded flex items-center"
                  >
                    <Link className="w-4 h-4 mr-2 text-purple-600" />
                    <span>Media Link</span>
                  </button>
                </div>
              )}
            </div>
          </div>

          {currentScene.hotspots.length > 0 && (
            <div className="absolute bottom-4 left-4 bg-gray-800 bg-opacity-95 rounded-lg p-4 max-w-xs max-h-64 overflow-y-auto">
              <h4 className="text-white font-semibold mb-3">Hotspots ({currentScene.hotspots.length})</h4>
              <div className="space-y-2">
                {currentScene.hotspots.map(hotspot => (
                  <div key={hotspot.id} className="flex justify-between items-center bg-gray-700 p-2 rounded text-sm">
                    <span className="flex items-center text-white flex-1">
                      {hotspot.iconUrl ? (
                        <img src={hotspot.iconUrl} alt="Custom" className="w-4 h-4 mr-2" />
                      ) : (
                        <>
                          {hotspot.type === 'navigation' && <Navigation className="w-4 h-4 mr-2 text-blue-400" />}
                          {hotspot.type === 'info' && <Info className="w-4 h-4 mr-2 text-green-400" />}
                          {hotspot.type === 'media' && <Link className="w-4 h-4 mr-2 text-purple-400" />}
                        </>
                      )}
                      <span className="truncate">
                        {hotspot.type === 'navigation' 
                          ? tour.scenes.find(s => s.id === hotspot.targetScene)?.name || 'Scene Link'
                          : hotspot.title || 'Hotspot'}
                      </span>
                    </span>
                    <div className="flex gap-1 ml-2">
                      <button
                        onClick={() => editHotspot(hotspot)}
                        className="text-blue-400 hover:text-blue-300 p-1"
                        title="Edit"
                      >
                        <Edit2 className="w-4 h-4" />
                      </button>
                      <button
                        onClick={() => deleteHotspot(hotspot.id)}
                        className="text-red-400 hover:text-red-300 p-1"
                        title="Delete"
                      >
                        <Trash2 className="w-4 h-4" />
                      </button>
                    </div>
                  </div>
                ))}
              </div>
            </div>
          )}

          {/* Hotspot Labels Overlay */}
          {showHotspotLabels && currentScene.hotspots.filter(h => h.showLabel !== false).map((hotspot, index) => {
            const labelText = hotspot.type === 'navigation' 
              ? tour.scenes.find(s => s.id === hotspot.targetScene)?.name || 'Scene Link'
              : hotspot.title || 'Hotspot';
            
            return (
              <div
                key={hotspot.id}
                ref={(el) => {
                  if (el) hotspotLabelsRef.current[index] = el;
                }}
                className="absolute pointer-events-none"
                style={{
                  transform: 'translate(-50%, -150%)',
                  zIndex: 10
                }}
              >
                <div 
                  className="text-white px-2 py-1 text-xs font-bold whitespace-nowrap"
                  style={{
                    textShadow: '0 2px 8px rgba(0,0,0,0.8), 0 4px 16px rgba(0,0,0,0.5), 0 1px 3px rgba(0,0,0,1)'
                  }}
                >
                  {labelText}
                </div>
              </div>
            );
          })}
        </div>

        {showHotspotForm && (
          <>
            {/* Semi-transparent overlay */}
            <div className="absolute inset-0 bg-black bg-opacity-20 z-40"></div>
            
            <HotspotForm
              type={hotspotType === 'info' ? infoHotspotType : hotspotType}
              tour={tour}
              currentSceneId={currentScene.id}
              existingData={editingHotspot}
              onSave={addHotspot}
              onLiveUpdate={editingHotspot ? handleLiveUpdate : null}
              onCancel={() => {
                setShowHotspotForm(false);
                setHotspotType(null);
                setInfoHotspotType(null);
                setHotspotData({});
                setEditingHotspot(null);
                setLivePreviewData(null);
              }}
            />
          </>
        )}
      </div>
    );
  };

  const HotspotForm = ({ type, tour, currentSceneId, existingData, onSave, onCancel, onLiveUpdate }) => {
    const [formData, setFormData] = useState({
      size: 1,
      opacity: 100,
      rotation: 0,
      showLabel: true,
      ...existingData
    });
    const [createReturnLink, setCreateReturnLink] = useState(true);
    const [iconUploadMethod, setIconUploadMethod] = useState(
      existingData?.iconUrl ? 'url' : 'default'
    );
    const iconInputRef = useRef(null);

    useEffect(() => {
      if (existingData) {
        setFormData({
          size: 1,
          opacity: 100,
          rotation: 0,
          showLabel: true,
          ...existingData
        });
        setIconUploadMethod(existingData.iconUrl ? 'url' : 'default');
      }
    }, [existingData]);

    // Live update whenever formData changes
    useEffect(() => {
      if (onLiveUpdate && (formData.size || formData.opacity || formData.rotation !== undefined || formData.iconUrl !== undefined || formData.inverted !== undefined)) {
        onLiveUpdate(formData);
      }
    }, [formData.size, formData.opacity, formData.rotation, formData.iconUrl, formData.inverted]);

    const handleIconUpload = (e) => {
      const file = e.target.files[0];
      if (file) {
        const reader = new FileReader();
        reader.onload = (event) => {
          setFormData({ ...formData, iconUrl: event.target.result });
        };
        reader.readAsDataURL(file);
      }
    };

    const handleSubmit = () => {
      if (type === 'navigation' && !formData.targetScene) return;
      if ((type === 'info' || type === 'media') && !formData.title) return;
      if (type === 'media' && (!formData.mediaType || !formData.content)) return;
      
      onSave(formData, type === 'navigation' && !existingData ? createReturnLink : false);
    };

    return (
      <div className="absolute inset-y-0 right-0 w-96 bg-white shadow-2xl z-50 flex flex-col border-l border-gray-200">
        <div className="bg-gray-800 text-white px-6 py-4 flex justify-between items-center">
          <h3 className="text-lg font-bold capitalize">{existingData ? 'Edit' : 'Add'} {type} Hotspot</h3>
          <button
            onClick={onCancel}
            className="text-gray-300 hover:text-white"
          >
            <X className="w-5 h-5" />
          </button>
        </div>

        <div className="flex-1 overflow-y-auto px-6 py-4 space-y-4">
          {type === 'navigation' && (
            <>
              <div>
                <label className="block text-sm font-medium mb-1">Link to Scene</label>
                <select
                  className="w-full px-4 py-2 border rounded-lg"
                  value={formData.targetScene || ''}
                  onChange={(e) => setFormData({ ...formData, targetScene: e.target.value })}
                >
                  <option value="" disabled>Choose a scene...</option>
                  {tour.scenes.filter(s => s.id !== currentSceneId).map(scene => (
                    <option key={scene.id} value={scene.id}>{scene.name}</option>
                  ))}
                </select>
                
                {/* Available Scenes Grid */}
                <div className="mt-3">
                  <div className="text-xs text-gray-600 mb-2 font-medium">Available Scenes:</div>
                  <div className="grid grid-cols-2 gap-2 max-h-64 overflow-y-auto p-1">
                    {tour.scenes.filter(s => s.id !== currentSceneId).map(scene => (
                      <button
                        key={scene.id}
                        type="button"
                        onClick={() => setFormData({ ...formData, targetScene: scene.id })}
                        className={`p-2 rounded-lg border-2 transition-all text-left ${
                          formData.targetScene === scene.id 
                            ? 'border-blue-500 bg-blue-50' 
                            : 'border-gray-200 hover:border-gray-400 hover:bg-gray-50'
                        }`}
                      >
                        <div className="w-full aspect-video bg-gray-100 rounded mb-1 overflow-hidden">
                          <img 
                            src={scene.imageUrl} 
                            alt={scene.name}
                            className="w-full h-full object-cover"
                            onError={(e) => {
                              e.target.style.display = 'none';
                            }}
                          />
                        </div>
                        <div className="text-xs font-medium truncate text-gray-800">{scene.name}</div>
                      </button>
                    ))}
                  </div>
                </div>
              </div>

              {/* Icon Color Selection */}
              <div>
                <label className="block text-sm font-medium mb-2">Icon Color</label>
                <div className="space-y-2">
                  <label className="flex items-center cursor-pointer">
                    <input
                      type="radio"
                      name="iconColor"
                      checked={!formData.inverted}
                      onChange={() => setFormData({ ...formData, inverted: false })}
                      className="mr-2"
                    />
                    <span className="text-sm">Default White</span>
                  </label>
                  <label className="flex items-center cursor-pointer">
                    <input
                      type="radio"
                      name="iconColor"
                      checked={formData.inverted === true}
                      onChange={() => setFormData({ ...formData, inverted: true })}
                      className="mr-2"
                    />
                    <span className="text-sm">Default Black</span>
                  </label>
                </div>
              </div>

              {/* Create Return Link - Only for new hotspots */}
              {!existingData && (
                <div className="pt-4 border-t">
                  <label className="flex items-center cursor-pointer">
                    <input
                      type="checkbox"
                      checked={createReturnLink}
                      onChange={(e) => setCreateReturnLink(e.target.checked)}
                      className="mr-2"
                    />
                    <span className="text-sm font-medium">Create Return Link</span>
                  </label>
                  <p className="text-xs text-gray-500 mt-1 ml-6">
                    Automatically create a hotspot in the target scene linking back to this scene
                  </p>
                </div>
              )}
            </>
          )}

          {type === 'info' && (
            <>
              <div>
                <label className="block text-sm font-medium mb-1">Title</label>
                <input
                  type="text"
                  className="w-full px-4 py-2 border rounded-lg"
                  placeholder="e.g., Historic Feature"
                  value={formData.title || ''}
                  onChange={(e) => setFormData({ ...formData, title: e.target.value })}
                />
              </div>
              <div>
                <label className="block text-sm font-medium mb-1">Description</label>
                <textarea
                  rows="3"
                  className="w-full px-4 py-2 border rounded-lg"
                  placeholder="Add details about this point..."
                  value={formData.description || ''}
                  onChange={(e) => setFormData({ ...formData, description: e.target.value })}
                />
              </div>
            </>
          )}

          {type === 'media' && (
            <>
              <div>
                <label className="block text-sm font-medium mb-1">Title</label>
                <input
                  type="text"
                  className="w-full px-4 py-2 border rounded-lg"
                  placeholder="e.g., Video Tour"
                  value={formData.title || ''}
                  onChange={(e) => setFormData({ ...formData, title: e.target.value })}
                />
              </div>
              <div>
                <label className="block text-sm font-medium mb-1">Media Type</label>
                <select
                  className="w-full px-4 py-2 border rounded-lg"
                  value={formData.mediaType || ''}
                  onChange={(e) => setFormData({ ...formData, mediaType: e.target.value })}
                >
                  <option value="" disabled>Select type...</option>
                  <option value="video">Video</option>
                  <option value="url">External Link</option>
                </select>
              </div>
              <div>
                <label className="block text-sm font-medium mb-1">URL</label>
                <input
                  type="text"
                  className="w-full px-4 py-2 border rounded-lg"
                  placeholder="Enter URL..."
                  value={formData.content || ''}
                  onChange={(e) => setFormData({ ...formData, content: e.target.value })}
                />
              </div>
            </>
          )}

          {/* Size Slider */}
          <div className="pt-4 border-t">
            <label className="block text-sm font-medium mb-2">
              Size: {formData.size || 1}x
            </label>
            <input
              type="range"
              min="0.5"
              max="3"
              step="0.1"
              value={formData.size || 1}
              onChange={(e) => setFormData({ ...formData, size: parseFloat(e.target.value) })}
              className="w-full"
            />
            <div className="flex justify-between text-xs text-gray-500 mt-1">
              <span>0.5x</span>
              <span>3x</span>
            </div>
          </div>

          {/* Opacity Slider */}
          <div>
            <label className="block text-sm font-medium mb-2">
              Opacity: {formData.opacity || 100}%
            </label>
            <input
              type="range"
              min="0"
              max="100"
              step="5"
              value={formData.opacity || 100}
              onChange={(e) => setFormData({ ...formData, opacity: parseInt(e.target.value) })}
              className="w-full"
            />
            <div className="flex justify-between text-xs text-gray-500 mt-1">
              <span>0%</span>
              <span>100%</span>
            </div>
          </div>

          {/* Rotation Slider */}
          <div>
            <label className="block text-sm font-medium mb-2">
              Rotation: {formData.rotation || 0}°
            </label>
            <input
              type="range"
              min="0"
              max="360"
              step="5"
              value={formData.rotation || 0}
              onChange={(e) => setFormData({ ...formData, rotation: parseInt(e.target.value) })}
              className="w-full"
            />
            <div className="flex justify-between text-xs text-gray-500 mt-1">
              <span>0°</span>
              <span>360°</span>
            </div>
          </div>

          {/* Show Label Checkbox */}
          <div className="pt-4 border-t">
            <label className="flex items-center cursor-pointer">
              <input
                type="checkbox"
                checked={formData.showLabel !== false}
                onChange={(e) => setFormData({ ...formData, showLabel: e.target.checked })}
                className="mr-2"
              />
              <span className="text-sm font-medium">Show Hotspot Label</span>
            </label>
            <p className="text-xs text-gray-500 mt-1 ml-6">
              Display the label above this hotspot when labels are enabled
            </p>
          </div>

          {/* Custom Icon Upload */}
          <div className="pt-4 border-t">
            <label className="block text-sm font-medium mb-2">Custom Icon (optional)</label>
            <div className="flex gap-2 mb-2">
              <button
                type="button"
                onClick={() => {
                  setIconUploadMethod('default');
                  setFormData({ ...formData, iconUrl: null });
                }}
                className={`flex-1 px-3 py-1 text-sm rounded border ${iconUploadMethod === 'default' ? 'bg-blue-600 text-white border-blue-600' : 'bg-white text-gray-700 border-gray-300'}`}
              >
                Default
              </button>
              <button
                type="button"
                onClick={() => setIconUploadMethod('url')}
                className={`flex-1 px-3 py-1 text-sm rounded border ${iconUploadMethod === 'url' ? 'bg-blue-600 text-white border-blue-600' : 'bg-white text-gray-700 border-gray-300'}`}
              >
                URL
              </button>
              <button
                type="button"
                onClick={() => setIconUploadMethod('file')}
                className={`flex-1 px-3 py-1 text-sm rounded border ${iconUploadMethod === 'file' ? 'bg-blue-600 text-white border-blue-600' : 'bg-white text-gray-700 border-gray-300'}`}
              >
                Upload
              </button>
            </div>
            
            {iconUploadMethod === 'url' && (
              <div>
                <input
                  type="text"
                  className="w-full px-4 py-2 border rounded-lg text-sm"
                  placeholder="https://example.com/icon.png"
                  value={formData.iconUrl || ''}
                  onChange={(e) => setFormData({ ...formData, iconUrl: e.target.value })}
                />
                <p className="text-xs text-gray-500 mt-1">Use transparent PNG for best results</p>
              </div>
            )}
            
            {iconUploadMethod === 'file' && (
              <div>
                <input
                  ref={iconInputRef}
                  type="file"
                  accept="image/png,image/jpeg,image/jpg,image/svg+xml"
                  onChange={handleIconUpload}
                  className="w-full px-4 py-2 border rounded-lg text-sm"
                />
                {formData.iconUrl && (
                  <div className="mt-2 flex items-center gap-2">
                    <img src={formData.iconUrl} alt="Icon preview" className="w-8 h-8 border rounded" />
                    <p className="text-xs text-green-600">✓ Icon uploaded</p>
                  </div>
                )}
              </div>
            )}
          </div>
        </div>

        {/* Save/Cancel Buttons */}
        <div className="border-t bg-gray-50 px-6 py-4 flex gap-3">
          <button
            onClick={handleSubmit}
            className="flex-1 bg-blue-600 text-white py-3 rounded-lg hover:bg-blue-700 font-medium"
          >
            {existingData ? 'Update' : 'Save'} Hotspot
          </button>
          <button
            onClick={onCancel}
            className="flex-1 bg-gray-200 text-gray-700 py-3 rounded-lg hover:bg-gray-300 font-medium"
          >
            Cancel
          </button>
        </div>
      </div>
    );
  };

  const CarouselEditor = ({ tour, onClose, onSave }) => {
    const [sections, setSections] = useState(tour.carouselSections || []);
    const [editingSection, setEditingSection] = useState(null);
    const [editingSectionName, setEditingSectionName] = useState('');
    const [showAddSection, setShowAddSection] = useState(false);
    const [newSectionName, setNewSectionName] = useState('');
    const [editingItem, setEditingItem] = useState(null);
    const [showItemForm, setShowItemForm] = useState(null); // { sectionId }
    const [itemFormData, setItemFormData] = useState({ title: '', sceneId: '', iconUrl: '' });
    const [draggedSection, setDraggedSection] = useState(null);
    const [draggedItem, setDraggedItem] = useState(null);
    const [showSceneMenu, setShowSceneMenu] = useState(tour.displaySettings?.showSceneMenu !== false);
    const [showSlideshow, setShowSlideshow] = useState(tour.displaySettings?.showSlideshow !== false);

    const addSection = () => {
      if (!newSectionName.trim()) return;
      const newSection = {
        id: Date.now().toString(),
        title: newSectionName,
        items: []
      };
      setSections([...sections, newSection]);
      setNewSectionName('');
      setShowAddSection(false);
    };

    const deleteSection = (sectionId) => {
      if (!window.confirm('Delete this section and all its items?')) return;
      setSections(sections.filter(s => s.id !== sectionId));
    };

    const startEditSection = (section) => {
      setEditingSection(section.id);
      setEditingSectionName(section.title);
    };

    const saveSection = () => {
      if (!editingSectionName.trim()) return;
      setSections(sections.map(s => 
        s.id === editingSection ? { ...s, title: editingSectionName } : s
      ));
      setEditingSection(null);
    };

    const updateItem = (sectionId) => {
      if (!itemFormData.title.trim()) return;
      
      setSections(sections.map(s => 
        s.id === sectionId 
          ? { 
              ...s, 
              items: s.items.map(item => 
                item.id === editingItem.id 
                  ? { 
                      ...item, 
                      title: itemFormData.title,
                      iconUrl: itemFormData.iconUrl || null
                    }
                  : item
              )
            }
          : s
      ));

      setEditingItem(null);
      setShowItemForm(null);
      setItemFormData({ title: '', sceneId: '', iconUrl: '' });
    };

    const deleteItem = (sectionId, itemId) => {
      setSections(sections.map(s => 
        s.id === sectionId 
          ? { ...s, items: s.items.filter(i => i.id !== itemId) }
          : s
      ));
    };

    const startEditItem = (sectionId, item) => {
      setEditingItem(item);
      setShowItemForm({ sectionId });
      setItemFormData({
        title: item.title,
        iconUrl: item.iconUrl || '',
        sceneId: item.sceneId // Keep for reference
      });
    };

    const moveSection = (fromIndex, toIndex) => {
      const newSections = [...sections];
      const [movedSection] = newSections.splice(fromIndex, 1);
      newSections.splice(toIndex, 0, movedSection);
      setSections(newSections);
    };

    const moveItem = (sectionId, fromIndex, toIndex) => {
      setSections(sections.map(s => {
        if (s.id === sectionId) {
          const newItems = [...s.items];
          const [movedItem] = newItems.splice(fromIndex, 1);
          newItems.splice(toIndex, 0, movedItem);
          return { ...s, items: newItems };
        }
        return s;
      }));
    };

    return (
      <div className="fixed inset-0 bg-black bg-opacity-75 flex items-center justify-center p-4 z-50">
        <div className="bg-white rounded-lg w-full max-w-4xl h-[80vh] flex flex-col">
          {/* Header */}
          <div className="bg-green-600 text-white px-6 py-4 rounded-t-lg flex justify-between items-center">
            <h2 className="text-2xl font-bold">Scene Menu Editor</h2>
            <button onClick={onClose} className="text-white hover:text-gray-200">
              <X className="w-6 h-6" />
            </button>
          </div>

          {/* Content */}
          <div className="flex-1 overflow-y-auto p-6">
            {sections.length === 0 ? (
              <div className="text-center py-12">
                <Navigation className="w-16 h-16 text-gray-300 mx-auto mb-4" />
                <p className="text-gray-500 mb-4">No sections yet. Create your first section!</p>
              </div>
            ) : (
              <div className="space-y-4">
                {sections.map((section, sectionIndex) => (
                  <div key={section.id} className="border rounded-lg">
                    {/* Section Header */}
                    <div className="bg-gray-100 p-4 flex justify-between items-center gap-4">
                      <div className="flex items-center gap-3 flex-1 min-w-0">
                        <div className="flex flex-col gap-1 flex-shrink-0">
                          <button
                            onClick={() => moveSection(sectionIndex, Math.max(0, sectionIndex - 1))}
                            disabled={sectionIndex === 0}
                            className="text-gray-400 hover:text-gray-600 disabled:opacity-30"
                          >
                            <ChevronUp className="w-4 h-4" />
                          </button>
                          <button
                            onClick={() => moveSection(sectionIndex, Math.min(sections.length - 1, sectionIndex + 1))}
                            disabled={sectionIndex === sections.length - 1}
                            className="text-gray-400 hover:text-gray-600 disabled:opacity-30"
                          >
                            <ChevronDown className="w-4 h-4" />
                          </button>
                        </div>
                        
                        {editingSection === section.id ? (
                          <input
                            type="text"
                            value={editingSectionName}
                            onChange={(e) => setEditingSectionName(e.target.value)}
                            onBlur={saveSection}
                            onKeyPress={(e) => e.key === 'Enter' && saveSection()}
                            className="flex-1 px-3 py-1 border rounded"
                            autoFocus
                          />
                        ) : (
                          <h3 className="text-lg font-semibold flex-1 truncate">{section.title}</h3>
                        )}
                      </div>
                      
                      <div className="flex gap-2 flex-shrink-0">
                        <button
                          onClick={(e) => {
                            e.stopPropagation();
                            startEditSection(section);
                          }}
                          className="text-blue-600 hover:text-blue-800 p-1"
                          title="Edit section name"
                        >
                          <Edit2 className="w-4 h-4" />
                        </button>
                        <button
                          onClick={(e) => {
                            e.stopPropagation();
                            setShowItemForm({ sectionId: section.id });
                          }}
                          className="text-green-600 hover:text-green-800 p-1"
                          title="Add item"
                        >
                          <Plus className="w-4 h-4" />
                        </button>
                        <button
                          onClick={(e) => {
                            e.stopPropagation();
                            deleteSection(section.id);
                          }}
                          className="text-red-600 hover:text-red-800 p-1"
                          title="Delete section"
                        >
                          <Trash2 className="w-4 h-4" />
                        </button>
                      </div>
                    </div>

                    {/* Section Items */}
                    <div className="p-4 space-y-2">
                      {section.items.length === 0 ? (
                        <p className="text-gray-400 text-sm text-center py-4">No items yet. Click + to add one.</p>
                      ) : (
                        section.items.map((item, itemIndex) => {
                          const scene = tour.scenes.find(s => s.id === item.sceneId);
                          
                          return (
                            <div key={item.id} className="flex items-center gap-3 bg-gray-50 p-3 rounded">
                              <div className="flex flex-col gap-1">
                                <button
                                  onClick={() => moveItem(section.id, itemIndex, Math.max(0, itemIndex - 1))}
                                  disabled={itemIndex === 0}
                                  className="text-gray-400 hover:text-gray-600 disabled:opacity-30"
                                >
                                  <ChevronUp className="w-3 h-3" />
                                </button>
                                <button
                                  onClick={() => moveItem(section.id, itemIndex, Math.min(section.items.length - 1, itemIndex + 1))}
                                  disabled={itemIndex === section.items.length - 1}
                                  className="text-gray-400 hover:text-gray-600 disabled:opacity-30"
                                >
                                  <ChevronDown className="w-3 h-3" />
                                </button>
                              </div>
                              
                              <span className="font-semibold text-gray-600">{itemIndex + 1}.</span>
                              
                              {scene && (
                                <div className="w-12 h-12 rounded overflow-hidden bg-gray-200 flex-shrink-0">
                                  <img src={scene.imageUrl} alt="" className="w-full h-full object-cover" />
                                </div>
                              )}
                              
                              <div className="flex-1 min-w-0">
                                <p className="font-medium truncate">{item.title}</p>
                                <p className="text-xs text-gray-500 truncate">
                                  {scene?.name || 'Unknown Scene'}
                                </p>
                              </div>
                              
                              <div className="flex gap-1">
                                <button
                                  onClick={() => startEditItem(section.id, item)}
                                  className="text-blue-600 hover:text-blue-800 p-1"
                                >
                                  <Edit2 className="w-4 h-4" />
                                </button>
                                <button
                                  onClick={() => deleteItem(section.id, item.id)}
                                  className="text-red-600 hover:text-red-800 p-1"
                                >
                                  <Trash2 className="w-4 h-4" />
                                </button>
                              </div>
                            </div>
                          );
                        })
                      )}
                    </div>

                    {/* Item Picker (if adding) */}
                    {showItemForm?.sectionId === section.id && !editingItem && (
                      <div className="p-4 bg-blue-50 border-t">
                        <div className="flex justify-between items-center mb-3">
                          <h4 className="font-semibold">Select a Scene</h4>
                          <button
                            onClick={() => {
                              setShowItemForm(null);
                              setItemFormData({ title: '', sceneId: '', iconUrl: '' });
                            }}
                            className="text-gray-500 hover:text-gray-700"
                          >
                            <X className="w-5 h-5" />
                          </button>
                        </div>
                        
                        <div className="grid grid-cols-2 gap-3 max-h-96 overflow-y-auto">
                          {tour.scenes.map(scene => (
                            <button
                              key={scene.id}
                              onClick={() => {
                                const newItem = {
                                  id: Date.now().toString(),
                                  title: scene.name,
                                  sceneId: scene.id,
                                  iconUrl: null
                                };
                                
                                setSections(sections.map(s => 
                                  s.id === section.id 
                                    ? { ...s, items: [...s.items, newItem] }
                                    : s
                                ));
                                
                                setShowItemForm(null);
                              }}
                              className="flex flex-col bg-white hover:bg-gray-50 border-2 border-gray-200 hover:border-blue-400 rounded-lg p-3 text-left transition"
                            >
                              {/* Thumbnail */}
                              <div className="w-full aspect-video bg-gray-100 rounded mb-2 overflow-hidden">
                                <img 
                                  src={scene.imageUrl} 
                                  alt={scene.name}
                                  className="w-full h-full object-cover"
                                />
                              </div>
                              
                              {/* Title */}
                              <div className="font-medium text-sm truncate">
                                {scene.name}
                              </div>
                            </button>
                          ))}
                        </div>
                        
                        {tour.scenes.length === 0 && (
                          <p className="text-gray-500 text-center py-8">
                            No scenes found. Create some scenes first.
                          </p>
                        )}
                      </div>
                    )}

                    {/* Edit Item Form */}
                    {showItemForm?.sectionId === section.id && editingItem && (
                      <div className="p-4 bg-blue-50 border-t">
                        <h4 className="font-semibold mb-3">Edit Item</h4>
                        <div className="space-y-3">
                          <div>
                            <label className="block text-sm font-medium mb-1">Item Title</label>
                            <input
                              type="text"
                              value={itemFormData.title}
                              onChange={(e) => setItemFormData({ ...itemFormData, title: e.target.value })}
                              placeholder="e.g., Historic Old Town"
                              className="w-full px-3 py-2 border rounded"
                            />
                          </div>
                          
                          <div>
                            <label className="block text-sm font-medium mb-1">Custom Icon URL (optional)</label>
                            <input
                              type="text"
                              value={itemFormData.iconUrl}
                              onChange={(e) => setItemFormData({ ...itemFormData, iconUrl: e.target.value })}
                              placeholder="https://example.com/icon.png"
                              className="w-full px-3 py-2 border rounded"
                            />
                          </div>
                          
                          <div className="flex gap-2">
                            <button
                              onClick={() => updateItem(section.id)}
                              className="flex-1 bg-blue-600 text-white py-2 rounded hover:bg-blue-700"
                            >
                              Update Item
                            </button>
                            <button
                              onClick={() => {
                                setShowItemForm(null);
                                setEditingItem(null);
                                setItemFormData({ title: '', sceneId: '', iconUrl: '' });
                              }}
                              className="flex-1 bg-gray-200 py-2 rounded hover:bg-gray-300"
                            >
                              Cancel
                            </button>
                          </div>
                        </div>
                      </div>
                    )}
                  </div>
                ))}
              </div>
            )}

            {/* Add Section Form */}
            {showAddSection && (
              <div className="mt-4 p-4 bg-green-50 rounded-lg border border-green-200">
                <h4 className="font-semibold mb-3">New Section</h4>
                <input
                  type="text"
                  value={newSectionName}
                  onChange={(e) => setNewSectionName(e.target.value)}
                  placeholder="Section name..."
                  className="w-full px-3 py-2 border rounded mb-3"
                  autoFocus
                  onKeyPress={(e) => e.key === 'Enter' && addSection()}
                />
                <div className="flex gap-2">
                  <button
                    onClick={addSection}
                    className="flex-1 bg-green-600 text-white py-2 rounded hover:bg-green-700"
                  >
                    Create Section
                  </button>
                  <button
                    onClick={() => {
                      setShowAddSection(false);
                      setNewSectionName('');
                    }}
                    className="flex-1 bg-gray-200 py-2 rounded hover:bg-gray-300"
                  >
                    Cancel
                  </button>
                </div>
              </div>
            )}
          </div>

          {/* Footer */}
          <div className="border-t p-4">
            {/* Display Settings */}
            <div className="bg-gray-50 rounded-lg p-3 mb-4">
              <h4 className="font-semibold text-sm mb-3 text-gray-700">Viewer Display Options</h4>
              <div className="space-y-2">
                <label className="flex items-center justify-between cursor-pointer hover:bg-white p-2 rounded">
                  <span className="text-sm text-gray-700">Show Scene Menu (Left Panel)</span>
                  <input
                    type="checkbox"
                    checked={showSceneMenu}
                    onChange={(e) => setShowSceneMenu(e.target.checked)}
                    className="w-4 h-4"
                  />
                </label>
                
                <label className="flex items-center justify-between cursor-pointer hover:bg-white p-2 rounded">
                  <span className="text-sm text-gray-700">Show Slideshow (Bottom Carousel)</span>
                  <input
                    type="checkbox"
                    checked={showSlideshow}
                    onChange={(e) => setShowSlideshow(e.target.checked)}
                    className="w-4 h-4"
                  />
                </label>
              </div>
            </div>
            
            {/* Action Buttons */}
            <div className="flex justify-between">
              <button
                onClick={() => setShowAddSection(true)}
                className="bg-green-600 text-white px-4 py-2 rounded hover:bg-green-700 flex items-center"
              >
                <Plus className="w-4 h-4 mr-2" />
                Add Section
              </button>
              
              <div className="flex gap-2">
                <button
                  onClick={onClose}
                  className="px-4 py-2 bg-gray-200 rounded hover:bg-gray-300"
                >
                  Cancel
                </button>
                <button
                  onClick={() => {
                    onSave(sections, { showSceneMenu, showSlideshow });
                    onClose();
                  }}
                  className="px-4 py-2 bg-blue-600 text-white rounded hover:bg-blue-700"
                >
                  Save Changes
                </button>
              </div>
            </div>
          </div>
        </div>
      </div>
    );
  };

  const TourEditor = () => {
    const [showAddSceneModal, setShowAddSceneModal] = useState(false);
    const [newSceneName, setNewSceneName] = useState('');
    const [newSceneImage, setNewSceneImage] = useState('');
    const [uploadMethod, setUploadMethod] = useState('url');
    const [deleteConfirm, setDeleteConfirm] = useState(null);
    const [previewMode, setPreviewMode] = useState(false);
    const [editingTourName, setEditingTourName] = useState(false);
    const [tourNameValue, setTourNameValue] = useState('');
    const [editingScene, setEditingScene] = useState(null);
    const [editSceneName, setEditSceneName] = useState('');
    const [sidebarCollapsed, setSidebarCollapsed] = useState(false);
    const [showLabelsInEditor, setShowLabelsInEditor] = useState(selectedTour?.showLabels !== false); // Default true
    const [openSceneMenu, setOpenSceneMenu] = useState(null);
    const [menuPosition, setMenuPosition] = useState({ top: 0, left: 0 });
    const [swapSceneModal, setSwapSceneModal] = useState(null);
    const [draggedScene, setDraggedScene] = useState(null);
    const [showCarouselEditor, setShowCarouselEditor] = useState(false);
    const fileInputRef = useRef(null);
    const swapFileInputRef = useRef(null);
    const isInitializingLabels = useRef(false);

    // Sync showLabelsInEditor with selectedTour when tour changes
    useEffect(() => {
      if (selectedTour) {
        isInitializingLabels.current = true;
        setShowLabelsInEditor(selectedTour.showLabels !== false);
        // Reset flag after state update completes
        setTimeout(() => {
          isInitializingLabels.current = false;
        }, 0);
      }
    }, [selectedTour?.id]);

    // Update tour when labels toggle changes (but not during initialization)
    useEffect(() => {
      if (selectedTour && !isInitializingLabels.current) {
        const updatedTour = { ...selectedTour, showLabels: showLabelsInEditor };
        setSelectedTour(updatedTour);
        setTours(prevTours => 
          prevTours.map(t => t.id === selectedTour.id ? updatedTour : t)
        );
      }
    }, [showLabelsInEditor, selectedTour]);

    const handleFileUpload = (e) => {
      const file = e.target.files[0];
      if (file) {
        const reader = new FileReader();
        reader.onload = (event) => {
          setNewSceneImage(event.target.result);
        };
        reader.readAsDataURL(file);
      }
    };

    const addScene = () => {
      if (!newSceneName.trim() || !newSceneImage) return;
      
      const newScene = {
        id: Date.now().toString(),
        name: newSceneName,
        imageUrl: newSceneImage,
        hotspots: []
      };
      
      const updatedTour = {
        ...selectedTour,
        scenes: [...selectedTour.scenes, newScene]
      };
      
      setTours(tours.map(t => t.id === selectedTour.id ? updatedTour : t));
      setSelectedTour(updatedTour);
      setNewSceneName('');
      setNewSceneImage('');
      setUploadMethod('url');
      setShowAddSceneModal(false);
    };

    const deleteScene = (sceneId) => {
      const updatedTour = {
        ...selectedTour,
        scenes: selectedTour.scenes.filter(s => s.id !== sceneId)
      };
      setTours(tours.map(t => t.id === selectedTour.id ? updatedTour : t));
      setSelectedTour(updatedTour);
      if (selectedScene && selectedScene.id === sceneId) {
        setSelectedScene(updatedTour.scenes[0] || null);
        setEditMode(false);
      }
      setDeleteConfirm(null);
    };

    const startEditTourName = () => {
      setEditingTourName(true);
      setTourNameValue(selectedTour.name);
    };

    const saveTourName = () => {
      if (!tourNameValue.trim()) return;
      const updatedTour = { ...selectedTour, name: tourNameValue };
      setTours(tours.map(t => t.id === selectedTour.id ? updatedTour : t));
      setSelectedTour(updatedTour);
      setEditingTourName(false);
    };

    const startEditSceneName = (scene, e) => {
      e.stopPropagation();
      setEditingScene(scene.id);
      setEditSceneName(scene.name);
    };

    const saveSceneName = () => {
      if (!editSceneName.trim()) return;
      const updatedTour = {
        ...selectedTour,
        scenes: selectedTour.scenes.map(s => 
          s.id === editingScene ? { ...s, name: editSceneName } : s
        )
      };
      setTours(tours.map(t => t.id === selectedTour.id ? updatedTour : t));
      setSelectedTour(updatedTour);
      if (selectedScene?.id === editingScene) {
        setSelectedScene({ ...selectedScene, name: editSceneName });
      }
      setEditingScene(null);
      setEditSceneName('');
    };

    const handleDragStart = (e, scene) => {
      setDraggedScene(scene);
      e.dataTransfer.effectAllowed = 'move';
    };

    const handleDragOver = (e) => {
      e.preventDefault();
      e.dataTransfer.dropEffect = 'move';
    };

    const handleDrop = (e, targetScene) => {
      e.preventDefault();
      e.stopPropagation();
      
      if (!draggedScene || draggedScene.id === targetScene.id) return;

      const scenes = [...selectedTour.scenes];
      const draggedIndex = scenes.findIndex(s => s.id === draggedScene.id);
      const targetIndex = scenes.findIndex(s => s.id === targetScene.id);

      // Reorder scenes
      const [removed] = scenes.splice(draggedIndex, 1);
      scenes.splice(targetIndex, 0, removed);

      const updatedTour = { ...selectedTour, scenes };
      setTours(tours.map(t => t.id === selectedTour.id ? updatedTour : t));
      setSelectedTour(updatedTour);
      setDraggedScene(null);
    };

    const toggleHideFromRibbon = (sceneId, e) => {
      e.stopPropagation();
      const updatedTour = {
        ...selectedTour,
        scenes: selectedTour.scenes.map(s =>
          s.id === sceneId ? { ...s, hideFromRibbon: !s.hideFromRibbon } : s
        )
      };
      setTours(tours.map(t => t.id === selectedTour.id ? updatedTour : t));
      setSelectedTour(updatedTour);
      setOpenSceneMenu(null);
    };

    const openSwapSceneModal = (scene, e) => {
      e.stopPropagation();
      setSwapSceneModal(scene);
      setNewSceneImage('');
      setUploadMethod('url');
      setOpenSceneMenu(null);
    };

    const swapSceneImage = () => {
      if (!newSceneImage || !swapSceneModal) return;
      
      const updatedTour = {
        ...selectedTour,
        scenes: selectedTour.scenes.map(s =>
          s.id === swapSceneModal.id ? { ...s, imageUrl: newSceneImage } : s
        )
      };
      setTours(tours.map(t => t.id === selectedTour.id ? updatedTour : t));
      setSelectedTour(updatedTour);
      
      if (selectedScene?.id === swapSceneModal.id) {
        setSelectedScene({ ...selectedScene, imageUrl: newSceneImage });
      }
      
      setSwapSceneModal(null);
      setNewSceneImage('');
    };

    const handleSwapFileUpload = (e) => {
      const file = e.target.files[0];
      if (file) {
        if (file.size > 2 * 1024 * 1024) {
          setStorageWarning('Warning: Files over 2MB may cause storage issues in some browsers.');
        }
        const reader = new FileReader();
        reader.onload = (event) => {
          setNewSceneImage(event.target.result);
        };
        reader.readAsDataURL(file);
      }
    };

    return (
      <div className="h-screen bg-gray-900 flex flex-col overflow-hidden">
        {previewMode ? (
          <div className="relative h-screen">
            <TourViewer
              key={`preview-${selectedTour.id}-${selectedTour.showLabels}`}
              tour={selectedTour}
              initialScene={selectedTour.scenes[0]}
              onBack={() => setPreviewMode(false)}
            />
            <div className="absolute top-4 right-4 bg-blue-600 text-white px-4 py-2 rounded-lg shadow-lg flex items-center gap-2">
              <Eye className="w-4 h-4" />
              Preview Mode
            </div>
          </div>
        ) : (
          <>
            <nav className="bg-gray-800 text-white shadow-lg">
              <div className="px-4 py-3 flex justify-between items-center">
                <div className="flex items-center gap-4">
                  <button
                    onClick={() => {
                      setSelectedTour(null);
                      setSelectedScene(null);
                      setEditMode(false);
                      setCurrentView('dashboard');
                    }}
                    className="text-gray-300 hover:text-white"
                  >
                    ← Back to Dashboard
                  </button>
                  <div className="flex items-center gap-2">
                    {editingTourName ? (
                      <input
                        type="text"
                        value={tourNameValue}
                        onChange={(e) => setTourNameValue(e.target.value)}
                        onBlur={saveTourName}
                        onKeyPress={(e) => {
                          if (e.key === 'Enter') saveTourName();
                        }}
                        className="text-xl font-bold bg-gray-700 text-white px-3 py-1 border border-gray-600 rounded"
                        autoFocus
                      />
                    ) : (
                      <>
                        <h1 className="text-xl font-bold">{selectedTour.name}</h1>
                        <button
                          onClick={startEditTourName}
                          className="text-gray-400 hover:text-white p-1"
                          title="Edit tour name"
                        >
                          <Edit2 className="w-4 h-4" />
                        </button>
                      </>
                    )}
                  </div>
                </div>
                <div className="flex gap-2">
                  {selectedTour.scenes.length > 0 && (
                    <>
                      <button
                        onClick={() => setPreviewMode(true)}
                        className="bg-purple-600 text-white px-4 py-2 rounded-lg hover:bg-purple-700 flex items-center"
                      >
                        <Eye className="w-4 h-4 mr-2" />
                        Preview
                      </button>
                      
                      <button
                        onClick={() => setShowCarouselEditor(true)}
                        className="bg-green-600 text-white px-4 py-2 rounded-lg hover:bg-green-700 flex items-center"
                      >
                        <Navigation className="w-4 h-4 mr-2" />
                        Scene Menu
                      </button>
                      
                      {/* Show Labels Toggle */}
                      <label className="bg-gray-700 text-white px-4 py-2 rounded-lg flex items-center cursor-pointer hover:bg-gray-600">
                        <input
                          type="checkbox"
                          checked={showLabelsInEditor}
                          onChange={(e) => setShowLabelsInEditor(e.target.checked)}
                          className="mr-2"
                        />
                        <span className="text-sm">Show Labels</span>
                      </label>
                    </>
                  )}
                  <button
                    onClick={() => setShowAddSceneModal(true)}
                    className="bg-blue-600 text-white px-4 py-2 rounded-lg hover:bg-blue-700 flex items-center"
                  >
                    <Plus className="w-4 h-4 mr-2" />
                    Add Scene
                  </button>
                </div>
              </div>
            </nav>

        {selectedTour.scenes.length === 0 ? (
          <div className="flex-1 flex items-center justify-center text-white">
            <div className="text-center">
              <Camera className="w-16 h-16 text-gray-500 mx-auto mb-4" />
              <p className="text-xl mb-2">No scenes yet</p>
              <p className="text-gray-400 mb-4">Add your first 360° scene to start building your tour</p>
              <button
                onClick={() => setShowAddSceneModal(true)}
                className="bg-blue-600 text-white px-6 py-3 rounded-lg hover:bg-blue-700 flex items-center mx-auto"
              >
                <Plus className="w-5 h-5 mr-2" />
                Add First Scene
              </button>
            </div>
          </div>
        ) : (
          <div className="flex-1 flex overflow-hidden">
            <div className={`bg-gray-800 overflow-y-auto transition-all duration-300 relative ${sidebarCollapsed ? 'w-12' : 'w-80'}`}>
              {/* Collapse/Expand Button */}
              <button
                onClick={() => setSidebarCollapsed(!sidebarCollapsed)}
                className="absolute top-4 right-2 z-10 bg-gray-700 hover:bg-gray-600 text-white p-2 rounded-lg shadow-lg"
                title={sidebarCollapsed ? "Expand sidebar" : "Collapse sidebar"}
              >
                {sidebarCollapsed ? (
                  <ChevronDown className="w-4 h-4 transform rotate-90" />
                ) : (
                  <ChevronUp className="w-4 h-4 transform rotate-90" />
                )}
              </button>

              {!sidebarCollapsed && (
                <div className="p-4">
                  <h3 className="text-white font-semibold mb-3">Scenes ({selectedTour.scenes.length})</h3>
                  <div className="space-y-2">
                  {selectedTour.scenes.map((scene, index) => (
                    <div
                      key={scene.id}
                      draggable
                      onDragStart={(e) => handleDragStart(e, scene)}
                      onDragOver={handleDragOver}
                      onDrop={(e) => handleDrop(e, scene)}
                      className={`bg-gray-700 rounded-lg cursor-pointer transition relative ${
                        selectedScene?.id === scene.id ? 'ring-2 ring-blue-500' : 'hover:bg-gray-600'
                      }`}
                      onClick={() => {
                        setSelectedScene(scene);
                        setEditMode(true);
                      }}
                    >
                      <div className="h-32 bg-gray-900 relative group overflow-hidden rounded-lg">
                        {/* Drag Handle - Top Left */}
                        <div 
                          className="absolute top-2 left-2 z-10 bg-gray-800 bg-opacity-90 p-1.5 rounded cursor-grab active:cursor-grabbing"
                          onMouseDown={(e) => e.stopPropagation()}
                        >
                          <div className="flex flex-col gap-0.5">
                            <ChevronUp className="w-3 h-3 text-white" />
                            <ChevronDown className="w-3 h-3 text-white" />
                          </div>
                        </div>

                        {/* Scene Image */}
                        {scene.imageUrl ? (
                          <img 
                            src={scene.imageUrl} 
                            alt={scene.name} 
                            className="w-full h-full object-cover"
                          />
                        ) : (
                          <div className="flex items-center justify-center h-full text-gray-500">
                            <Camera className="w-8 h-8" />
                          </div>
                        )}

                        {/* Hidden from Ribbon Indicator */}
                        {scene.hideFromRibbon && (
                          <div className="absolute top-2 right-2 bg-red-600 bg-opacity-90 p-1.5 rounded">
                            <EyeOff className="w-4 h-4 text-white" />
                          </div>
                        )}

                        {/* Editing Badge */}
                        {selectedScene?.id === scene.id && !scene.hideFromRibbon && (
                          <div className="absolute top-2 right-2 bg-blue-600 text-white px-2 py-1 rounded text-xs">
                            Editing
                          </div>
                        )}

                        {/* Floating Island at Bottom */}
                        <div className="absolute bottom-2 left-2 right-2 bg-black bg-opacity-55 px-3 py-0 flex items-center justify-between rounded-full" style={{ height: '24px' }}>
                          {/* Scene Name - Double Click to Edit */}
                          {editingScene === scene.id ? (
                            <input
                              type="text"
                              value={editSceneName}
                              onChange={(e) => setEditSceneName(e.target.value)}
                              onBlur={saveSceneName}
                              onKeyPress={(e) => {
                                e.stopPropagation();
                                if (e.key === 'Enter') saveSceneName();
                              }}
                              onClick={(e) => e.stopPropagation()}
                              className="text-white bg-gray-700 font-medium text-sm flex-1 px-2 py-1 border border-gray-500 rounded"
                              autoFocus
                            />
                          ) : (
                            <h4 
                              className="text-white font-medium text-sm flex-1 truncate"
                              onDoubleClick={(e) => startEditSceneName(scene, e)}
                            >
                              {scene.name}
                            </h4>
                          )}

                          {/* Three Dot Menu */}
                          <div className="relative">
                            <button
                              onClick={(e) => {
                                e.stopPropagation();
                                const rect = e.currentTarget.getBoundingClientRect();
                                setMenuPosition({
                                  top: rect.bottom + 4,
                                  left: rect.left - 192 + rect.width // 192px = w-48
                                });
                                setOpenSceneMenu(openSceneMenu === scene.id ? null : scene.id);
                              }}
                              className="text-white hover:text-gray-300 p-1"
                            >
                              <span className="text-lg font-bold">⋯</span>
                            </button>
                          </div>
                        </div>
                      </div>
                    </div>
                  ))}

                  {/* Render menu outside scene cards to avoid clipping */}
                  {openSceneMenu && (
                    <>
                      {/* Click Outside to Close */}
                      <div 
                        className="fixed inset-0 z-40"
                        onClick={() => setOpenSceneMenu(null)}
                      />
                      
                      {/* Menu Content */}
                      <div 
                        className="fixed bg-white rounded-lg shadow-xl py-2 w-48 z-50"
                        style={{
                          top: `${menuPosition.top}px`,
                          left: `${menuPosition.left}px`
                        }}
                      >
                        {selectedTour.scenes.map(scene => {
                          if (scene.id === openSceneMenu) {
                            return (
                              <div key={scene.id}>
                                {/* Hide from Ribbon */}
                                <label 
                                  className="flex items-center px-4 py-2 hover:bg-gray-100 cursor-pointer"
                                  onClick={(e) => {
                                    e.stopPropagation();
                                    toggleHideFromRibbon(scene.id, e);
                                  }}
                                >
                                  <input
                                    type="checkbox"
                                    checked={scene.hideFromRibbon || false}
                                    onChange={() => {}}
                                    className="mr-3"
                                  />
                                  <span className="text-sm text-gray-700">Hide from Ribbon</span>
                                </label>

                                {/* Swap Scene */}
                                <button
                                  onClick={(e) => openSwapSceneModal(scene, e)}
                                  className="w-full flex items-center px-4 py-2 hover:bg-gray-100 text-left"
                                >
                                  <Camera className="w-4 h-4 mr-3 text-gray-600" />
                                  <span className="text-sm text-gray-700">Swap Scene</span>
                                </button>

                                {/* Delete Scene */}
                                <button
                                  onClick={(e) => {
                                    e.stopPropagation();
                                    setDeleteConfirm({ type: 'scene', id: scene.id, name: scene.name });
                                    setOpenSceneMenu(null);
                                  }}
                                  className="w-full flex items-center px-4 py-2 hover:bg-red-50 text-left"
                                >
                                  <Trash2 className="w-4 h-4 mr-3 text-red-600" />
                                  <span className="text-sm text-red-600">Delete Scene</span>
                                </button>
                              </div>
                            );
                          }
                          return null;
                        })}
                      </div>
                    </>
                  )}
                </div>
              </div>
              )}
            </div>

            <div className="flex-1 bg-black h-full overflow-hidden">
              {editMode && selectedScene ? (
                <SceneEditor
                  scene={selectedScene}
                  tour={selectedTour}
                  tours={tours}
                  setTours={setTours}
                  setSelectedTour={setSelectedTour}
                  showHotspotLabels={showLabelsInEditor}
                  onSave={(updatedScene) => {
                    const updatedTour = {
                      ...selectedTour,
                      scenes: selectedTour.scenes.map(s => s.id === updatedScene.id ? updatedScene : s)
                    };
                    setTours(tours.map(t => t.id === selectedTour.id ? updatedTour : t));
                    setSelectedTour(updatedTour);
                    setSelectedScene(updatedScene);
                  }}
                />
              ) : (
                <div className="h-full flex items-center justify-center text-gray-500">
                  <div className="text-center">
                    <Camera className="w-16 h-16 mx-auto mb-4 opacity-50" />
                    <p>Select a scene from the left to start editing</p>
                  </div>
                </div>
              )}
            </div>
          </div>
        )}

        {showAddSceneModal && (
          <div className="fixed inset-0 bg-black bg-opacity-75 flex items-center justify-center p-4 z-50">
            <div className="bg-white rounded-lg p-6 w-full max-w-md">
              <h3 className="text-xl font-bold mb-4">Add New Scene</h3>
              <div className="space-y-4">
                <div>
                  <label className="block text-sm font-medium mb-1">Scene Name</label>
                  <input
                    type="text"
                    value={newSceneName}
                    onChange={(e) => setNewSceneName(e.target.value)}
                    placeholder="e.g., Living Room"
                    className="w-full px-4 py-2 border rounded-lg"
                    onKeyPress={(e) => e.key === 'Enter' && addScene()}
                  />
                </div>
                
                <div>
                  <label className="block text-sm font-medium mb-2">Upload Method</label>
                  <div className="flex gap-2 mb-3">
                    <button
                      type="button"
                      onClick={() => setUploadMethod('url')}
                      className={`flex-1 px-4 py-2 rounded-lg border ${uploadMethod === 'url' ? 'bg-blue-600 text-white border-blue-600' : 'bg-white text-gray-700 border-gray-300'}`}
                    >
                      Use URL (Recommended)
                    </button>
                    <button
                      type="button"
                      onClick={() => setUploadMethod('file')}
                      className={`flex-1 px-4 py-2 rounded-lg border ${uploadMethod === 'file' ? 'bg-blue-600 text-white border-blue-600' : 'bg-white text-gray-700 border-gray-300'}`}
                    >
                      Upload File
                    </button>
                  </div>
                </div>

                {uploadMethod === 'url' ? (
                  <div>
                    <label className="block text-sm font-medium mb-1">360° Image URL</label>
                    <input
                      type="text"
                      value={newSceneImage}
                      onChange={(e) => setNewSceneImage(e.target.value)}
                      placeholder="https://i.imgur.com/example.jpg"
                      className="w-full px-4 py-2 border rounded-lg"
                    />
                    <p className="text-xs text-blue-600 mt-1">💡 Right-click image on Imgur → "Copy image address"</p>
                  </div>
                ) : (
                  <div>
                    <label className="block text-sm font-medium mb-1">Upload 360° Image</label>
                    <input
                      ref={fileInputRef}
                      type="file"
                      accept="image/jpeg,image/jpg,image/png"
                      onChange={handleFileUpload}
                      className="w-full px-4 py-2 border rounded-lg"
                    />
                    <p className="text-xs text-yellow-600 mt-1">⚠️ Keep files under 2MB</p>
                    {newSceneImage && (
                      <p className="text-xs text-green-600 mt-1">✓ Image uploaded successfully</p>
                    )}
                  </div>
                )}
              </div>
              <div className="flex gap-2 mt-6">
                <button
                  onClick={addScene}
                  disabled={!newSceneName.trim() || !newSceneImage}
                  className={`flex-1 py-2 rounded-lg transition ${
                    newSceneName.trim() && newSceneImage
                      ? 'bg-blue-600 text-white hover:bg-blue-700 cursor-pointer'
                      : 'bg-gray-300 text-gray-500 cursor-not-allowed'
                  }`}
                >
                  Add Scene
                </button>
                <button
                  onClick={() => {
                    setShowAddSceneModal(false);
                    setNewSceneName('');
                    setNewSceneImage('');
                    setUploadMethod('url');
                  }}
                  className="flex-1 bg-gray-200 text-gray-700 py-2 rounded-lg hover:bg-gray-300"
                >
                  Cancel
                </button>
              </div>
            </div>
          </div>
        )}

        {/* Swap Scene Modal */}
        {swapSceneModal && (
          <div className="fixed inset-0 bg-black bg-opacity-75 flex items-center justify-center p-4 z-50">
            <div className="bg-white rounded-lg p-6 w-full max-w-md">
              <h3 className="text-xl font-bold mb-4">Swap Scene Image</h3>
              <p className="text-sm text-gray-600 mb-4">Replace the 360° image for "{swapSceneModal.name}". All hotspots and settings will be preserved.</p>
              
              <div className="space-y-4">
                <div>
                  <label className="block text-sm font-medium mb-2">Upload Method</label>
                  <div className="flex gap-2 mb-3">
                    <button
                      type="button"
                      onClick={() => setUploadMethod('url')}
                      className={`flex-1 px-4 py-2 rounded-lg border ${uploadMethod === 'url' ? 'bg-blue-600 text-white border-blue-600' : 'bg-white text-gray-700 border-gray-300'}`}
                    >
                      Use URL (Recommended)
                    </button>
                    <button
                      type="button"
                      onClick={() => setUploadMethod('file')}
                      className={`flex-1 px-4 py-2 rounded-lg border ${uploadMethod === 'file' ? 'bg-blue-600 text-white border-blue-600' : 'bg-white text-gray-700 border-gray-300'}`}
                    >
                      Upload File
                    </button>
                  </div>
                </div>

                {uploadMethod === 'url' ? (
                  <div>
                    <label className="block text-sm font-medium mb-1">New 360° Image URL</label>
                    <input
                      type="text"
                      value={newSceneImage}
                      onChange={(e) => setNewSceneImage(e.target.value)}
                      placeholder="https://i.imgur.com/example.jpg"
                      className="w-full px-4 py-2 border rounded-lg"
                    />
                    <p className="text-xs text-blue-600 mt-1">💡 Right-click image on Imgur → "Copy image address"</p>
                  </div>
                ) : (
                  <div>
                    <label className="block text-sm font-medium mb-1">Upload New 360° Image</label>
                    <input
                      ref={swapFileInputRef}
                      type="file"
                      accept="image/jpeg,image/jpg,image/png"
                      onChange={handleSwapFileUpload}
                      className="w-full px-4 py-2 border rounded-lg"
                    />
                    <p className="text-xs text-yellow-600 mt-1">⚠️ Keep files under 2MB</p>
                    {newSceneImage && (
                      <p className="text-xs text-green-600 mt-1">✓ Image uploaded successfully</p>
                    )}
                  </div>
                )}
              </div>
              
              <div className="flex gap-2 mt-6">
                <button
                  onClick={swapSceneImage}
                  disabled={!newSceneImage}
                  className={`flex-1 py-2 rounded-lg transition ${
                    newSceneImage
                      ? 'bg-blue-600 text-white hover:bg-blue-700 cursor-pointer'
                      : 'bg-gray-300 text-gray-500 cursor-not-allowed'
                  }`}
                >
                  Swap Image
                </button>
                <button
                  onClick={() => {
                    setSwapSceneModal(null);
                    setNewSceneImage('');
                    setUploadMethod('url');
                  }}
                  className="flex-1 bg-gray-200 text-gray-700 py-2 rounded-lg hover:bg-gray-300"
                >
                  Cancel
                </button>
              </div>
            </div>
          </div>
        )}

        {deleteConfirm && (
          <div className="fixed inset-0 bg-black bg-opacity-75 flex items-center justify-center p-4 z-50">
            <div className="bg-white rounded-lg p-6 w-full max-w-md">
              <h3 className="text-xl font-bold mb-4">Delete Scene</h3>
              <p className="mb-6">Are you sure you want to delete <strong>"{deleteConfirm.name}"</strong>?</p>
              <div className="flex gap-2">
                <button
                  onClick={() => deleteScene(deleteConfirm.id)}
                  className="flex-1 bg-red-600 text-white py-2 rounded-lg hover:bg-red-700"
                >
                  Delete
                </button>
                <button
                  onClick={() => setDeleteConfirm(null)}
                  className="flex-1 bg-gray-200 text-gray-700 py-2 rounded-lg hover:bg-gray-300"
                >
                  Cancel
                </button>
              </div>
            </div>
          </div>
        )}

        {/* Carousel Editor Modal */}
        {showCarouselEditor && (
          <CarouselEditor
            tour={selectedTour}
            onClose={() => setShowCarouselEditor(false)}
            onSave={(updatedCarouselSections, displaySettings) => {
              const updatedTour = {
                ...selectedTour,
                carouselSections: updatedCarouselSections,
                displaySettings: displaySettings
              };
              setTours(tours.map(t => t.id === selectedTour.id ? updatedTour : t));
              setSelectedTour(updatedTour);
            }}
          />
        )}
          </>
        )}
      </div>
    );
  };

  // MapView Component - Full-screen map overlay with scene markers
  const MapView = ({ tour, currentScene, onClose, onNavigate }) => {
    const mapContainerRef = useRef(null);
    const mapRef = useRef(null);
    const markersRef = useRef([]);
    const [mapboxLoaded, setMapboxLoaded] = useState(false);
    const [loadError, setLoadError] = useState(false);
    const [showCarousel, setShowCarousel] = useState(tour.displaySettings?.showSceneMenu !== false);
    const [expandedSections, setExpandedSections] = useState({});
    const [activeItemId, setActiveItemId] = useState(null);

    // Load Mapbox GL JS dynamically
    useEffect(() => {
      if (window.mapboxgl) {
        setMapboxLoaded(true);
        return;
      }

      const link = document.createElement('link');
      link.href = 'https://api.mapbox.com/mapbox-gl-js/v3.0.1/mapbox-gl.css';
      link.rel = 'stylesheet';
      document.head.appendChild(link);

      const script = document.createElement('script');
      script.src = 'https://api.mapbox.com/mapbox-gl-js/v3.0.1/mapbox-gl.js';
      script.onload = () => {
        console.log('Mapbox GL loaded successfully');
        setMapboxLoaded(true);
      };
      script.onerror = () => {
        console.error('Failed to load Mapbox GL');
        setLoadError(true);
      };
      document.head.appendChild(script);

      // Timeout fallback
      const timeout = setTimeout(() => {
        if (!window.mapboxgl) {
          console.error('Mapbox GL loading timeout');
          setLoadError(true);
        }
      }, 10000);

      return () => {
        clearTimeout(timeout);
        if (link.parentNode) link.parentNode.removeChild(link);
        if (script.parentNode) script.parentNode.removeChild(script);
      };
    }, []);

    // Initialize map
    useEffect(() => {
      if (!mapboxLoaded || !mapContainerRef.current || mapRef.current) return;

      try {
        // Find scenes with locations
        const scenesWithLocations = tour.scenes.filter(s => s.location?.lat && s.location?.lng);
        
        if (scenesWithLocations.length === 0) {
          console.warn('No scenes with locations found');
        }

        // Calculate center from all scene locations
        const center = scenesWithLocations.length > 0
          ? [
              scenesWithLocations.reduce((sum, s) => sum + s.location.lng, 0) / scenesWithLocations.length,
              scenesWithLocations.reduce((sum, s) => sum + s.location.lat, 0) / scenesWithLocations.length
            ]
          : [-106.9120, 32.8998]; // Default Alamogordo

        window.mapboxgl.accessToken = MAPBOX_TOKEN;
        const map = new window.mapboxgl.Map({
          container: mapContainerRef.current,
          style: 'mapbox://styles/mapbox/streets-v12',
          center: center,
          zoom: 12,
          pitch: 45, // 3D tilt
          bearing: 0,
          antialias: true
        });

        map.addControl(new window.mapboxgl.NavigationControl());

        map.on('load', () => {
          console.log('Map loaded successfully');
          
          // Add markers for scenes with locations
          if (scenesWithLocations.length > 0) {
            addSimpleMarkers(map, scenesWithLocations);
          }
        });

        map.on('error', (e) => {
          console.error('Map error:', e);
        });

        mapRef.current = map;

        return () => {
          if (mapRef.current) {
            mapRef.current.remove();
            mapRef.current = null;
          }
        };
      } catch (error) {
        console.error('Error initializing map:', error);
        setLoadError(true);
      }
    }, [mapboxLoaded, tour.scenes]);

    const addSimpleMarkers = (map, scenesWithLocations) => {
      scenesWithLocations.forEach(scene => {
        const el = document.createElement('div');
        el.className = 'custom-marker';
        el.style.cssText = `
          width: 100px;
          cursor: pointer;
          display: flex;
          flex-direction: column;
          align-items: center;
          gap: 4px;
        `;

        const thumbnail = document.createElement('div');
        thumbnail.style.cssText = `
          width: 80px;
          height: 60px;
          border-radius: 8px;
          overflow: hidden;
          box-shadow: 0 4px 12px rgba(0,0,0,0.4);
          border: ${scene.id === currentScene.id ? '3px solid #3B82F6' : '2px solid white'};
          background: #333;
        `;
        
        const img = document.createElement('img');
        img.src = scene.imageUrl;
        img.style.cssText = 'width: 100%; height: 100%; object-fit: cover;';
        thumbnail.appendChild(img);

        const label = document.createElement('div');
        label.textContent = scene.name;
        label.style.cssText = `
          background: rgba(0,0,0,0.8);
          color: white;
          padding: 4px 8px;
          border-radius: 4px;
          font-size: 12px;
          font-weight: bold;
          white-space: nowrap;
          max-width: 100px;
          overflow: hidden;
          text-overflow: ellipsis;
        `;

        el.appendChild(thumbnail);
        el.appendChild(label);

        el.addEventListener('click', () => {
          onNavigate(scene);
        });

        new window.mapboxgl.Marker({ element: el })
          .setLngLat([scene.location.lng, scene.location.lat])
          .addTo(map);
      });
    };

    if (loadError) {
      return (
        <div className="fixed inset-0 bg-black bg-opacity-75 flex items-center justify-center z-50">
          <div className="bg-white rounded-lg p-6 max-w-md text-center">
            <X className="w-16 h-16 text-red-600 mx-auto mb-4" />
            <h3 className="text-xl font-bold mb-2">Map Failed to Load</h3>
            <p className="text-gray-600 mb-4">
              The map cannot load in the Claude.ai artifact environment due to security restrictions.
            </p>
            <p className="text-sm text-gray-500 mb-4">
              To use the map feature, download the app and run it on your own domain.
            </p>
            <button
              onClick={onClose}
              className="px-6 py-2 bg-blue-600 text-white rounded-lg hover:bg-blue-700"
            >
              Close
            </button>
          </div>
        </div>
      );
    }

    if (!mapboxLoaded) {
      return (
        <div className="fixed inset-0 bg-black bg-opacity-75 flex items-center justify-center z-50">
          <div className="text-white text-center">
            <div className="animate-spin rounded-full h-12 w-12 border-b-2 border-white mx-auto mb-4"></div>
            <div className="text-lg">Loading map...</div>
            <button
              onClick={onClose}
              className="mt-4 px-4 py-2 bg-gray-600 text-white rounded-lg hover:bg-gray-700"
            >
              Cancel
            </button>
          </div>
        </div>
      );
    }

    return (
      <div className="fixed inset-0 z-50">
        {/* Map Container */}
        <div ref={mapContainerRef} className="w-full h-full" />

        {/* Close Map Button */}
        <button
          onClick={onClose}
          className="absolute top-6 left-6 px-6 py-3 bg-blue-600 text-white rounded-full shadow-lg hover:bg-blue-700 transition flex items-center gap-2 font-bold"
        >
          <X className="w-5 h-5" />
          CLOSE MAP
        </button>

        {/* Carousel - Reuse existing carousel component */}
        {tour.carouselSections && tour.carouselSections.length > 0 && (
          <>
            {showCarousel ? (
              <div className="absolute left-6 top-1/2 transform -translate-y-1/2 flex flex-col gap-3">
                <div 
                  className="bg-opacity-95 backdrop-blur-sm overflow-hidden shadow-xl"
                  style={{
                    width: 'clamp(200px, 18vw, 260px)',
                    maxHeight: '45vh',
                    backgroundColor: 'rgba(142, 143, 134, 0.95)',
                    borderRadius: '20px'
                  }}
                >
                  <div className="overflow-y-auto h-full">
                    {tour.carouselSections.map((section, sectionIndex) => {
                      const isLast = sectionIndex === tour.carouselSections.length - 1;
                      const isExpanded = expandedSections[section.id];
                      
                      return (
                        <div key={section.id}>
                          <button
                            onClick={() => {
                              setExpandedSections({
                                [section.id]: !expandedSections[section.id]
                              });
                            }}
                            className="w-full px-4 py-3 flex justify-between items-center transition-all hover:brightness-105"
                            style={{ minHeight: '56px' }}
                          >
                            <span className="text-white font-bold text-base text-left pr-3">
                              {section.title}
                            </span>
                            <ChevronDown 
                              className={`w-5 h-5 text-white transition-transform flex-shrink-0 ${isExpanded ? 'rotate-180' : ''}`}
                            />
                          </button>
                          
                          {isExpanded && (
                            <div className="bg-black bg-opacity-10">
                              {section.items.map((item, itemIndex) => {
                                const scene = tour.scenes.find(s => s.id === item.sceneId);
                                const isActive = activeItemId === item.id;
                                const isLastItem = itemIndex === section.items.length - 1;
                                
                                return (
                                  <div key={item.id}>
                                    <button
                                      onClick={() => {
                                        if (scene) {
                                          onNavigate(scene);
                                          setActiveItemId(item.id);
                                        }
                                      }}
                                      className={`w-full px-5 py-3 transition-all hover:brightness-110 ${
                                        isActive ? 'bg-white bg-opacity-10' : ''
                                      }`}
                                      style={{ minHeight: '44px' }}
                                    >
                                      <div className="flex items-center gap-2">
                                        <span className="text-white font-semibold text-sm flex-shrink-0">
                                          {itemIndex + 1}.
                                        </span>
                                        {item.iconUrl && (
                                          <div className="w-4 h-4 flex-shrink-0">
                                            <img 
                                              src={item.iconUrl} 
                                              alt="" 
                                              className="w-full h-full object-contain"
                                            />
                                          </div>
                                        )}
                                        <span className="text-white text-sm text-left flex-1 truncate font-medium">
                                          {item.title}
                                        </span>
                                      </div>
                                    </button>
                                    {!isLastItem && (
                                      <div 
                                        className="mx-4 opacity-30"
                                        style={{ 
                                          height: '1px',
                                          backgroundColor: '#5A5A55'
                                        }}
                                      />
                                    )}
                                  </div>
                                );
                              })}
                            </div>
                          )}
                          
                          {!isLast && (
                            <div 
                              className="w-full opacity-40"
                              style={{ 
                                height: '1px',
                                backgroundColor: '#5A5A55'
                              }}
                            />
                          )}
                        </div>
                      );
                    })}
                  </div>
                </div>

                <button
                  onClick={() => setShowCarousel(false)}
                  className="px-4 py-3 rounded-lg shadow-lg transition-all hover:brightness-110 flex items-center gap-2 self-start"
                  style={{
                    backgroundColor: 'rgba(90, 90, 85, 0.95)',
                  }}
                >
                  <X className="w-4 h-4 text-white" />
                  <span className="text-white font-medium text-sm whitespace-nowrap">Close List</span>
                </button>
              </div>
            ) : (
              <button
                onClick={() => setShowCarousel(true)}
                className="absolute bottom-8 left-6 px-4 py-3 rounded-lg shadow-lg transition-all hover:brightness-110"
                style={{
                  backgroundColor: 'rgba(90, 90, 85, 0.95)',
                }}
              >
                <span className="text-white font-medium text-sm whitespace-nowrap">View List</span>
              </button>
            )}
          </>
        )}
      </div>
    );
  };

  const TourViewer = ({ tour, initialScene, onBack }) => {
    const [currentScene, setCurrentScene] = useState(initialScene);
    const [showInfo, setShowInfo] = useState(null);
    const [fromSceneId, setFromSceneId] = useState(null);
    const [showSlideshow, setShowSlideshow] = useState(tour.displaySettings?.showSlideshow !== false);
    const [slideScrollPosition, setSlideScrollPosition] = useState(0);
    const [showCarousel, setShowCarousel] = useState(tour.displaySettings?.showSceneMenu !== false);
    const [expandedSections, setExpandedSections] = useState({});
    const [activeItemId, setActiveItemId] = useState(null);
    const [showEmbedModal, setShowEmbedModal] = useState(false);
    const [embedModalConfig, setEmbedModalConfig] = useState(null);
    const [showMap, setShowMap] = useState(false);
    const viewerRef = useRef(null);
    const slideshowRef = useRef(null);
    const hotspotLabelsRef = useRef([]);

    // Auto-scroll carousel to center current scene
    useEffect(() => {
      if (slideshowRef.current && showSlideshow) {
        const visibleScenes = tour.scenes.filter(s => !s.hideFromRibbon);
        const currentIndex = visibleScenes.findIndex(s => s.id === currentScene.id);
        const thumbnailWidth = 104; // 96px width + 8px gap
        const scrollPosition = currentIndex * thumbnailWidth - (slideshowRef.current.offsetWidth / 2) + (thumbnailWidth / 2);
        slideshowRef.current.scrollTo({
          left: Math.max(0, scrollPosition),
          behavior: 'smooth'
        });
      }
    }, [currentScene, showSlideshow, tour.scenes]);

    // Keyboard navigation
    useEffect(() => {
      const handleKeyPress = (e) => {
        if (e.key === 'ArrowLeft') {
          const currentIndex = tour.scenes.findIndex(s => s.id === currentScene.id);
          const prevIndex = currentIndex > 0 ? currentIndex - 1 : tour.scenes.length - 1;
          setFromSceneId(currentScene.id);
          setCurrentScene(tour.scenes[prevIndex]);
        } else if (e.key === 'ArrowRight') {
          const currentIndex = tour.scenes.findIndex(s => s.id === currentScene.id);
          const nextIndex = currentIndex < tour.scenes.length - 1 ? currentIndex + 1 : 0;
          setFromSceneId(currentScene.id);
          setCurrentScene(tour.scenes[nextIndex]);
        }
      };

      window.addEventListener('keydown', handleKeyPress);
      return () => window.removeEventListener('keydown', handleKeyPress);
    }, [currentScene, tour.scenes]);

    useEffect(() => {
      if (!viewerRef.current || !currentScene) return;

      const scene3d = new THREE.Scene();
      const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
      const renderer = new THREE.WebGLRenderer({ antialias: true });
      
      renderer.setSize(window.innerWidth, window.innerHeight);
      viewerRef.current.innerHTML = '';
      viewerRef.current.appendChild(renderer.domElement);

      const geometry = new THREE.SphereGeometry(500, 256, 128);
      geometry.scale(-1, 1, 1);

      const loader = new THREE.TextureLoader();
      loader.crossOrigin = 'anonymous';
      const texture = loader.load(currentScene.imageUrl);
      texture.minFilter = THREE.LinearFilter;
      texture.magFilter = THREE.LinearFilter;
      const material = new THREE.MeshBasicMaterial({ map: texture, side: THREE.FrontSide });
      const sphere = new THREE.Mesh(geometry, material);
      scene3d.add(sphere);

      currentScene.hotspots.forEach(hotspot => {
        const hotspotSize = hotspot.size || 1;
        const hotspotOpacity = (hotspot.opacity !== undefined ? hotspot.opacity : 100) / 100;
        
        if (hotspot.iconUrl) {
          // Custom icon - use sprite with texture
          const textureLoader = new THREE.TextureLoader();
          textureLoader.crossOrigin = 'anonymous';
          textureLoader.load(
            hotspot.iconUrl,
            (texture) => {
              const spriteMaterial = new THREE.SpriteMaterial({ 
                map: texture,
                sizeAttenuation: false,
                transparent: true,
                opacity: hotspotOpacity,
                depthTest: false,
                depthWrite: false
              });
              const sprite = new THREE.Sprite(spriteMaterial);
              sprite.scale.set(0.24 * hotspotSize, 0.24 * hotspotSize, 1);
              sprite.renderOrder = 999;
              sprite.position.set(hotspot.position.x, hotspot.position.y, hotspot.position.z);
              if (hotspot.rotation) {
                sprite.material.rotation = (hotspot.rotation * Math.PI) / 180;
              }
              sprite.userData = hotspot;
              scene3d.add(sprite);
            },
            undefined,
            (err) => {
              console.error('Failed to load hotspot icon:', err);
              // Fallback to colored sphere
              addDefaultHotspot(hotspot, hotspotSize, hotspotOpacity);
            }
          );
        } else {
          // Default colored sphere
          addDefaultHotspot(hotspot, hotspotSize, hotspotOpacity);
        }
      });

      function addDefaultHotspot(hotspot, size = 1, opacity = 1) {
        // Navigation hotspots use sprite with custom icon
        if (hotspot.type === 'navigation') {
          const texture = createNavigationIconTexture(hotspot.inverted || false);
          const spriteMaterial = new THREE.SpriteMaterial({ 
            map: texture,
            transparent: true,
            opacity: opacity,
            sizeAttenuation: false,  // Keep constant screen size
            depthTest: false,  // Don't clip behind geometry
            depthWrite: false
          });
          const sprite = new THREE.Sprite(spriteMaterial);
          sprite.scale.set(0.24 * size, 0.24 * size, 1);  // Larger size (was 0.08)
          sprite.renderOrder = 999;  // Render on top
          sprite.position.set(hotspot.position.x, hotspot.position.y, hotspot.position.z);
          if (hotspot.rotation) {
            sprite.material.rotation = (hotspot.rotation * Math.PI) / 180; // Convert degrees to radians
          }
          sprite.userData = hotspot;
          scene3d.add(sprite);
          return;
        }
        
        // Other hotspot types use spheres
        const hotspotGeometry = new THREE.SphereGeometry(5 * size, 16, 16);
        let hotspotMaterial;
        
        if (hotspot.type === 'info') {
          hotspotMaterial = new THREE.MeshBasicMaterial({ 
            color: 0x00ff00,
            transparent: true,
            opacity: opacity
          });
        } else {
          hotspotMaterial = new THREE.MeshBasicMaterial({ 
            color: 0xff00ff,
            transparent: true,
            opacity: opacity
          });
        }

        const hotspotMesh = new THREE.Mesh(hotspotGeometry, hotspotMaterial);
        hotspotMesh.position.set(hotspot.position.x, hotspot.position.y, hotspot.position.z);
        hotspotMesh.userData = hotspot;
        scene3d.add(hotspotMesh);
      }

      camera.position.set(0, 0, 0.1);

      let viewing = false;
      let startX = 0;
      let startY = 0;
      
      // Determine initial view based on context
      let initialLon = 0;
      let initialLat = 0;
      
      if (currentScene.initialView) {
        // Check if coming from a specific scene with a custom view
        if (fromSceneId && currentScene.initialView.fromScenes?.[fromSceneId]) {
          initialLon = currentScene.initialView.fromScenes[fromSceneId].lon;
          initialLat = currentScene.initialView.fromScenes[fromSceneId].lat;
        } 
        // Otherwise use default view if set
        else if (currentScene.initialView.default) {
          initialLon = currentScene.initialView.default.lon;
          initialLat = currentScene.initialView.default.lat;
        }
      }
      
      let viewLon = initialLon;
      let viewLonStart = 0;
      let viewLat = initialLat;
      let viewLatStart = 0;
      
      // Inertia/momentum variables
      let velLon = 0;
      let velLat = 0;
      let lastMoveX = 0;
      let lastMoveY = 0;
      let lastMoveTime = Date.now();

      const handleDown = (event) => {
        viewing = true;
        startX = event.clientX;
        startY = event.clientY;
        viewLonStart = viewLon;
        viewLatStart = viewLat;
        // Reset velocity on new interaction
        velLon = 0;
        velLat = 0;
        lastMoveX = event.clientX;
        lastMoveY = event.clientY;
        lastMoveTime = Date.now();
      };

      const handleMove = (event) => {
        if (viewing) {
          const currentTime = Date.now();
          const deltaTime = Math.max(currentTime - lastMoveTime, 1); // Avoid division by zero
          
          // Calculate movement
          const deltaX = event.clientX - lastMoveX;
          const deltaY = event.clientY - lastMoveY;
          
          // Calculate velocity (pixels per millisecond)
          velLon = -(deltaX / deltaTime) * 0.15; // Negative for correct direction
          velLat = (deltaY / deltaTime) * 0.15;
          
          // Apply movement
          viewLon = (startX - event.clientX) * 0.15 + viewLonStart;
          viewLat = (event.clientY - startY) * 0.15 + viewLatStart;
          
          // Update last position and time
          lastMoveX = event.clientX;
          lastMoveY = event.clientY;
          lastMoveTime = currentTime;
        }
      };

      const handleUp = () => {
        viewing = false;
        // Clamp initial velocity to prevent excessive spinning
        const maxVel = 2.0;
        velLon = Math.max(-maxVel, Math.min(maxVel, velLon));
        velLat = Math.max(-maxVel * 0.5, Math.min(maxVel * 0.5, velLat)); // Weaker vertical
      };

      const handleClickEvent = (event) => {
        const mouse = new THREE.Vector2();
        mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
        mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

        const raycaster = new THREE.Raycaster();
        raycaster.params.Sprite = { threshold: 10 }; // Increase click area for sprites
        raycaster.setFromCamera(mouse, camera);
        
        // Check all objects in the scene that have userData (both sprites and meshes)
        const hotspotObjects = scene3d.children.filter(child => child.userData.id);
        const intersects = raycaster.intersectObjects(hotspotObjects);

        if (intersects.length > 0) {
          const hotspot = intersects[0].object.userData;
          
          if (hotspot.type === 'navigation') {
            const targetScene = tour.scenes.find(s => s.id === hotspot.targetScene);
            if (targetScene) {
              setFromSceneId(currentScene.id); // Track which scene we're coming from
              setCurrentScene(targetScene);
            }
          } else {
            setShowInfo(hotspot);
          }
        }
      };

      renderer.domElement.addEventListener('pointerdown', handleDown);
      renderer.domElement.addEventListener('pointermove', handleMove);
      renderer.domElement.addEventListener('pointerup', handleUp);
      renderer.domElement.addEventListener('click', handleClickEvent);

      const animate = () => {
        requestAnimationFrame(animate);
        
        // Apply inertia when not viewing/interacting
        if (!viewing) {
          // Apply velocity to rotation
          viewLon += velLon;
          viewLat += velLat;
          
          // Apply friction (0.92 = subtle slow down)
          const friction = 0.92;
          velLon *= friction;
          velLat *= friction;
          
          // Stop completely when velocity is very small
          if (Math.abs(velLon) < 0.01) velLon = 0;
          if (Math.abs(velLat) < 0.01) velLat = 0;
        }
        
        viewLat = Math.max(-85, Math.min(85, viewLat));
        const phi = THREE.MathUtils.degToRad(90 - viewLat);
        const theta = THREE.MathUtils.degToRad(viewLon);
        const target = new THREE.Vector3(
          500 * Math.sin(phi) * Math.cos(theta),
          500 * Math.cos(phi),
          500 * Math.sin(phi) * Math.sin(theta)
        );
        camera.lookAt(target);
        
        // Update hotspot label positions
        if ((tour.showLabels !== false) && hotspotLabelsRef.current.length > 0) {
          let labelIndex = 0;
          currentScene.hotspots.forEach((hotspot) => {
            if (hotspot.showLabel === false) return; // Skip hotspots with labels disabled
            
            const labelElement = hotspotLabelsRef.current[labelIndex];
            if (labelElement) {
              const vector = new THREE.Vector3(
                hotspot.position.x,
                hotspot.position.y + 15, // Offset above hotspot
                hotspot.position.z
              );
              vector.project(camera);
              
              const x = (vector.x * 0.5 + 0.5) * window.innerWidth;
              const y = (vector.y * -0.5 + 0.5) * window.innerHeight;
              
              // Check if behind camera
              const isBehind = vector.z > 1;
              
              labelElement.style.left = `${x}px`;
              labelElement.style.top = `${y}px`;
              labelElement.style.display = isBehind ? 'none' : 'block';
            }
            labelIndex++;
          });
        }
        
        renderer.render(scene3d, camera);
      };

      animate();

      const handleResize = () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      };

      window.addEventListener('resize', handleResize);

      return () => {
        window.removeEventListener('resize', handleResize);
        renderer.domElement.removeEventListener('pointerdown', handleDown);
        renderer.domElement.removeEventListener('pointermove', handleMove);
        renderer.domElement.removeEventListener('pointerup', handleUp);
        renderer.domElement.removeEventListener('click', handleClickEvent);
      };
    }, [currentScene, tour]);

    return (
      <div className="relative w-full h-screen">
        <div ref={viewerRef} className="w-full h-full" />
        
        <div className="absolute top-4 left-4 bg-white bg-opacity-90 rounded-lg p-4 shadow-lg">
          <button
            onClick={onBack}
            className="mb-2 text-blue-600 hover:text-blue-800 flex items-center"
          >
            ← Back to Tours
          </button>
          <h3 className="text-lg font-bold">{tour.name}</h3>
          <p className="text-sm text-gray-600">{currentScene.name}</p>
        </div>

        <div className="absolute top-4 right-4 bg-white bg-opacity-90 rounded-lg px-4 py-2 text-sm shadow-lg">
          Drag to look around • Click hotspots to interact
        </div>

        {/* Top HUD Display */}
        <TopHUD
          scene={currentScene}
          tour={tour}
          onNavigate={(sceneId) => {
            const targetScene = tour.scenes.find(s => s.id === sceneId);
            if (targetScene) {
              setFromSceneId(currentScene.id);
              setCurrentScene(targetScene);
            }
          }}
          onPopup={(button) => {
            setEmbedModalConfig(button);
            setShowEmbedModal(true);
          }}
        />

        {/* Embed Modal */}
        {showEmbedModal && embedModalConfig && (
          <EmbedModal
            embedConfig={embedModalConfig}
            onClose={() => {
              setShowEmbedModal(false);
              setEmbedModalConfig(null);
            }}
          />
        )}

        {/* Carousel Panel - Left Side */}
        {tour.carouselSections && tour.carouselSections.length > 0 && (
          <>
            {showCarousel ? (
              <div className="absolute left-6 top-1/2 transform -translate-y-1/2 flex flex-col gap-3">
                {/* Main Panel */}
                <div 
                  className="bg-opacity-95 backdrop-blur-sm overflow-hidden shadow-xl"
                  style={{
                    width: 'clamp(200px, 18vw, 260px)',
                    maxHeight: '45vh',
                    backgroundColor: 'rgba(142, 143, 134, 0.95)',
                    borderRadius: '20px'
                  }}
                >
                  {/* Scrollable Sections */}
                  <div className="overflow-y-auto h-full">
                    {tour.carouselSections.map((section, sectionIndex) => {
                      const isLast = sectionIndex === tour.carouselSections.length - 1;
                      const isExpanded = expandedSections[section.id];
                      
                      return (
                        <div key={section.id}>
                          {/* Section Header */}
                          <button
                            onClick={() => {
                              // Close all other sections, open only this one
                              setExpandedSections({
                                [section.id]: !expandedSections[section.id]
                              });
                            }}
                            className="w-full px-4 py-3 flex justify-between items-center transition-all hover:brightness-105"
                            style={{ minHeight: '56px' }}
                          >
                            <span className="text-white font-bold text-base text-left pr-3">
                              {section.title}
                            </span>
                            <ChevronDown 
                              className={`w-5 h-5 text-white transition-transform flex-shrink-0 ${isExpanded ? 'rotate-180' : ''}`}
                            />
                          </button>
                          
                          {/* Section Items */}
                          {isExpanded && (
                            <div className="bg-black bg-opacity-10">
                              {section.items.map((item, itemIndex) => {
                                const scene = tour.scenes.find(s => s.id === item.sceneId);
                                const isActive = activeItemId === item.id;
                                const isLastItem = itemIndex === section.items.length - 1;
                                
                                return (
                                  <div key={item.id}>
                                    <button
                                      onClick={() => {
                                        if (scene) {
                                          setFromSceneId(currentScene.id);
                                          setCurrentScene(scene);
                                          setActiveItemId(item.id);
                                        }
                                      }}
                                      className={`w-full px-5 py-3 transition-all hover:brightness-110 ${
                                        isActive ? 'bg-white bg-opacity-10' : ''
                                      }`}
                                      style={{ minHeight: '44px' }}
                                    >
                                      <div className="flex items-center gap-2">
                                        {/* Number */}
                                        <span className="text-white font-semibold text-sm flex-shrink-0">
                                          {itemIndex + 1}.
                                        </span>
                                        
                                        {/* Icon (optional) */}
                                        {item.iconUrl && (
                                          <div className="w-4 h-4 flex-shrink-0">
                                            <img 
                                              src={item.iconUrl} 
                                              alt="" 
                                              className="w-full h-full object-contain"
                                            />
                                          </div>
                                        )}
                                        
                                        {/* Title */}
                                        <span className="text-white text-sm text-left flex-1 truncate font-medium">
                                          {item.title}
                                        </span>
                                      </div>
                                    </button>
                                    
                                    {/* Item Separator */}
                                    {!isLastItem && (
                                      <div 
                                        className="mx-4 opacity-30"
                                        style={{ 
                                          height: '1px',
                                          backgroundColor: '#5A5A55'
                                        }}
                                      />
                                    )}
                                  </div>
                                );
                              })}
                            </div>
                          )}
                          
                          {/* Section Separator */}
                          {!isLast && (
                            <div 
                              className="w-full opacity-40"
                              style={{ 
                                height: '1px',
                                backgroundColor: '#5A5A55'
                              }}
                            />
                          )}
                        </div>
                      );
                    })}
                  </div>
                </div>

                {/* Close List Button - Below Panel */}
                <button
                  onClick={() => setShowCarousel(false)}
                  className="px-4 py-3 rounded-lg shadow-lg transition-all hover:brightness-110 flex items-center gap-2 self-start"
                  style={{
                    backgroundColor: 'rgba(90, 90, 85, 0.95)',
                  }}
                >
                  <X className="w-4 h-4 text-white" />
                  <span className="text-white font-medium text-sm whitespace-nowrap">Close List</span>
                </button>

                {/* Map View Button */}
                <button
                  onClick={() => setShowMap(true)}
                  className="px-4 py-3 rounded-lg shadow-lg transition-all hover:brightness-110 flex items-center gap-2 self-start"
                  style={{
                    backgroundColor: 'rgba(90, 90, 85, 0.95)',
                  }}
                >
                  <Map className="w-4 h-4 text-white" />
                  <span className="text-white font-medium text-sm whitespace-nowrap">Map View</span>
                </button>
              </div>
            ) : (
              <>
                {/* View List Button - Bottom Left Corner */}
                <button
                  onClick={() => setShowCarousel(true)}
                  className="absolute bottom-8 left-6 px-4 py-3 rounded-lg shadow-lg transition-all hover:brightness-110"
                  style={{
                    backgroundColor: 'rgba(90, 90, 85, 0.95)',
                  }}
                >
                  <span className="text-white font-medium text-sm whitespace-nowrap">View List</span>
                </button>

                {/* Map View Button - Below View List */}
                <button
                  onClick={() => setShowMap(true)}
                  className="absolute bottom-20 left-6 px-4 py-3 rounded-lg shadow-lg transition-all hover:brightness-110 flex items-center gap-2"
                  style={{
                    backgroundColor: 'rgba(90, 90, 85, 0.95)',
                  }}
                >
                  <Map className="w-4 h-4 text-white" />
                  <span className="text-white font-medium text-sm whitespace-nowrap">Map View</span>
                </button>
              </>
            )}
          </>
        )}

        {/* Hotspot Labels Overlay */}
        {(tour.showLabels !== false) && currentScene.hotspots.filter(h => h.showLabel !== false).map((hotspot, index) => {
          const labelText = hotspot.type === 'navigation' 
            ? tour.scenes.find(s => s.id === hotspot.targetScene)?.name || 'Scene Link'
            : hotspot.title || 'Hotspot';
          
          return (
            <div
              key={hotspot.id}
              ref={(el) => {
                if (el) {
                  hotspotLabelsRef.current[index] = el;
                }
              }}
              className="absolute pointer-events-none"
              style={{
                transform: 'translate(-50%, -150%)',
                zIndex: 10
              }}
            >
              <div 
                className="text-white px-3 py-1 text-sm font-bold whitespace-nowrap"
                style={{
                  textShadow: '0 2px 8px rgba(0,0,0,0.8), 0 4px 16px rgba(0,0,0,0.5), 0 1px 3px rgba(0,0,0,1)'
                }}
              >
                {labelText}
              </div>
            </div>
          );
        })}

        {showInfo && (
          <div className="absolute top-1/2 left-1/2 transform -translate-x-1/2 -translate-y-1/2 bg-white rounded-lg shadow-2xl p-6 max-w-md w-full mx-4">
            <div className="flex justify-between items-start mb-4">
              <h3 className="text-xl font-bold">{showInfo.title}</h3>
              <button
                onClick={() => setShowInfo(null)}
                className="text-gray-500 hover:text-gray-700"
              >
                <X className="w-6 h-6" />
              </button>
            </div>
            
            {showInfo.type === 'info' && (
              <>
                {showInfo.imageUrl && (
                  <img src={showInfo.imageUrl} alt={showInfo.title} className="w-full rounded-lg mb-4" />
                )}
                <p className="text-gray-700">{showInfo.description}</p>
              </>
            )}
            
            {showInfo.type === 'media' && (
              <>
                {showInfo.mediaType === 'video' && (
                  <video controls className="w-full rounded-lg">
                    <source src={showInfo.content} />
                  </video>
                )}
                {showInfo.mediaType === 'url' && (
                  <a
                    href={showInfo.content}
                    target="_blank"
                    rel="noopener noreferrer"
                    className="block w-full bg-blue-600 text-white text-center py-2 rounded-lg hover:bg-blue-700"
                  >
                    Visit Link
                  </a>
                )}
              </>
            )}
          </div>
        )}

        {/* Map View - Full Screen Overlay */}
        {showMap && (
          <MapView
            tour={tour}
            currentScene={currentScene}
            onClose={() => setShowMap(false)}
            onNavigate={(scene) => {
              setFromSceneId(currentScene.id);
              setCurrentScene(scene);
              setShowMap(false);
            }}
          />
        )}

        {/* Slide Carousel - Bottom Center */}
        <div className={`absolute bottom-4 left-1/2 transform -translate-x-1/2 transition-all duration-300 ${showSlideshow ? 'translate-y-0' : 'translate-y-full'}`}>
          <div className="flex flex-col items-center gap-2">
            {/* Hide/Show Toggle */}
            <button
              onClick={() => setShowSlideshow(!showSlideshow)}
              className="bg-white bg-opacity-90 hover:bg-opacity-100 rounded-full p-2 shadow-lg transition"
              title={showSlideshow ? "Hide slideshow" : "Show slideshow"}
            >
              {showSlideshow ? (
                <ChevronDown className="w-5 h-5 text-gray-700" />
              ) : (
                <ChevronUp className="w-5 h-5 text-gray-700" />
              )}
            </button>

            {showSlideshow && (
              <div className="bg-black bg-opacity-60 backdrop-blur-sm rounded-lg p-3 shadow-2xl">
                {/* Scene Counter */}
                <div className="text-center mb-2">
                  <span className="text-white text-sm font-medium">
                    Scene {tour.scenes.filter(s => !s.hideFromRibbon).findIndex(s => s.id === currentScene.id) + 1} / {tour.scenes.filter(s => !s.hideFromRibbon).length}
                  </span>
                </div>
                
                <div className="flex items-center gap-3">
                  {/* Left Arrow */}
                  <button
                    onClick={() => {
                      const currentIndex = tour.scenes.findIndex(s => s.id === currentScene.id);
                      const prevIndex = currentIndex > 0 ? currentIndex - 1 : tour.scenes.length - 1;
                      setFromSceneId(currentScene.id);
                      setCurrentScene(tour.scenes[prevIndex]);
                    }}
                    className="bg-white bg-opacity-80 hover:bg-opacity-100 rounded-full p-2 transition"
                  >
                    <ChevronUp className="w-5 h-5 text-gray-700 transform -rotate-90" />
                  </button>

                  {/* Thumbnails */}
                  <div 
                    ref={slideshowRef}
                    className="flex gap-2 overflow-x-auto max-w-xl scroll-smooth"
                    style={{ scrollbarWidth: 'none', msOverflowStyle: 'none' }}
                  >
                    <style>{`
                      div::-webkit-scrollbar {
                        display: none;
                      }
                    `}</style>
                    {tour.scenes.filter(scene => !scene.hideFromRibbon).map((scene) => (
                      <button
                        key={scene.id}
                        onClick={() => {
                          setFromSceneId(currentScene.id);
                          setCurrentScene(scene);
                        }}
                        className={`flex-shrink-0 rounded-lg overflow-hidden transition ${
                          currentScene.id === scene.id
                            ? 'ring-4 ring-blue-400 scale-105'
                            : 'ring-2 ring-white ring-opacity-50 hover:ring-blue-300'
                        }`}
                      >
                        <div className="relative w-24 h-16">
                          {scene.imageUrl ? (
                            <img
                              src={scene.imageUrl}
                              alt={scene.name}
                              className="w-full h-full object-cover"
                            />
                          ) : (
                            <div className="w-full h-full bg-gray-700 flex items-center justify-center">
                              <Camera className="w-6 h-6 text-gray-400" />
                            </div>
                          )}
                          {currentScene.id === scene.id && (
                            <div className="absolute inset-0 bg-blue-500 bg-opacity-20"></div>
                          )}
                        </div>
                        <div className="bg-black bg-opacity-70 px-2 py-1 text-white text-xs text-center truncate">
                          {scene.name}
                        </div>
                      </button>
                    ))}
                  </div>

                  {/* Right Arrow */}
                  <button
                    onClick={() => {
                      const currentIndex = tour.scenes.findIndex(s => s.id === currentScene.id);
                      const nextIndex = currentIndex < tour.scenes.length - 1 ? currentIndex + 1 : 0;
                      setFromSceneId(currentScene.id);
                      setCurrentScene(tour.scenes[nextIndex]);
                    }}
                    className="bg-white bg-opacity-80 hover:bg-opacity-100 rounded-full p-2 transition"
                  >
                    <ChevronDown className="w-5 h-5 text-gray-700 transform -rotate-90" />
                  </button>
                </div>
              </div>
            )}
          </div>
        </div>
      </div>
    );
  };

  const PublicViewer = () => {
    const publishedTours = tours.filter(t => t.published);

    if (viewerTour && viewerScene) {
      return (
        <TourViewer
          tour={viewerTour}
          initialScene={viewerScene}
          onBack={() => {
            setViewerTour(null);
            setViewerScene(null);
          }}
        />
      );
    }

    return (
      <div className="min-h-screen bg-gradient-to-br from-purple-500 to-blue-600">
        <nav className="bg-white bg-opacity-10 backdrop-blur-md">
          <div className="max-w-7xl mx-auto px-4 py-4 flex justify-between items-center">
            <div className="flex items-center text-white">
              <Camera className="w-8 h-8 mr-3" />
              <h1 className="text-2xl font-bold">Virtual Tours</h1>
            </div>
            <button
              onClick={() => setCurrentView('login')}
              className="text-white hover:bg-white hover:bg-opacity-20 px-4 py-2 rounded-lg transition"
            >
              Team Login
            </button>
          </div>
        </nav>

        <div className="max-w-7xl mx-auto px-4 py-12">
          <h2 className="text-3xl font-bold text-white text-center mb-8">Explore Our Virtual Tours</h2>
          
          <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6">
            {publishedTours.map(tour => (
              <div key={tour.id} className="bg-white rounded-lg shadow-xl overflow-hidden hover:shadow-2xl transition">
                {tour.scenes[0] && (
                  <div className="h-48 bg-gray-200">
                    <img src={tour.scenes[0].imageUrl} alt={tour.name} className="w-full h-full object-cover" />
                  </div>
                )}
                <div className="p-6">
                  <h3 className="text-xl font-semibold mb-2">{tour.name}</h3>
                  <p className="text-gray-600 mb-4">{tour.scenes.length} scenes to explore</p>
                  <button
                    onClick={() => {
                      setViewerTour(tour);
                      setViewerScene(tour.scenes[0]);
                    }}
                    className="w-full bg-gradient-to-r from-purple-600 to-blue-600 text-white py-2 rounded-lg hover:from-purple-700 hover:to-blue-700 flex items-center justify-center"
                  >
                    <Eye className="w-4 h-4 mr-2" />
                    Start Tour
                  </button>
                </div>
              </div>
            ))}
          </div>

          {publishedTours.length === 0 && (
            <div className="text-center py-12 text-white">
              <Camera className="w-16 h-16 mx-auto mb-4 opacity-50" />
              <p className="text-xl">No tours available yet. Check back soon!</p>
            </div>
          )}
        </div>
      </div>
    );
  };

  if (currentView === 'login') {
    return <LoginView />;
  } else if (currentView === 'dashboard') {
    return <Dashboard />;
  } else if (currentView === 'editor') {
    return <TourEditor />;
  } else if (currentView === 'public-viewer') {
    return <PublicViewer />;
  }

  return null;
};

export default VirtualTourApp;

    // Render the application
    const root = ReactDOM.createRoot(document.getElementById('root'));
    root.render(<VirtualTourApp />);
  </script>
</body>
</html>
